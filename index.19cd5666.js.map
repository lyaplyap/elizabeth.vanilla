{"mappings":"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","sources":["<anon>","src/scripts/index.js","src/scripts/app/controller.js","src/scripts/features/chat/view.js","src/scripts/shared/types.js","src/scripts/features/chat/templates.js","node_modules/marked/lib/marked.umd.js","node_modules/marked/src/defaults.ts","node_modules/marked/src/helpers.ts","node_modules/marked/src/Tokenizer.ts","node_modules/marked/src/rules.ts","node_modules/marked/src/Lexer.ts","node_modules/marked/src/Renderer.ts","node_modules/marked/src/TextRenderer.ts","node_modules/marked/src/Parser.ts","node_modules/marked/src/Hooks.ts","node_modules/marked/src/Instance.ts","node_modules/marked/src/marked.ts","src/scripts/features/chat/*.js","node_modules/@parcel/runtime-js/lib/runtime-dba52ad4f36a0dab.js","node_modules/@parcel/runtime-js/lib/runtime-a7edb1e262fe82b1.js","src/scripts/shared/utils.js","src/scripts/shared/*.js","node_modules/@parcel/runtime-js/lib/runtime-ecc9d45a93802994.js","node_modules/@parcel/runtime-js/lib/runtime-3b07c3ce2b319a4b.js","node_modules/@parcel/runtime-js/lib/runtime-d768b50f012465a3.js","src/scripts/shared/constants.js","src/scripts/features/menu/view.js","src/scripts/features/menu/templates.js","src/scripts/shared/api.js","src/scripts/app/model.js"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/**\n * @typedef {Object} Model - LLM\n * @property {Number} id - Идентификатор LLM (например, \"yandexgpt\")\n * @property {Boolean} [stream=false] - Флаг потоковой передачи ответа LLM\n * @property {Number} [temperature=0.6] - Коэффициент рандомности ответа LLM\n * @property {Number} [maxTokens=2000] - Максимальное количество токенов в ответе LLM\n */ /**\n * @typedef {Object} Message - Сообщение\n * @property {\"user\"|\"assistant\"|\"system\"} role - Роль отправителя сообщения\n * @property {String} text - Текст сообщения\n */ /**\n * @typedef {Object} Assistant - Ассистент\n * @property {String} id Идентификатор ассистента\n * @property {String} title Название ассистента\n * @property {String} [description] Описание ассистента (необязательное)\n * @property {String} [instruction] Промпт-инструкция ассистента\n * @property {Model} model Объект LLM, используемой ассистентом\n * @property {Message[]} messages Сообщения из чата с ассистентом\n */ const $76583e30775d534c$export$4624c240901a6889 = {};\n\n\nvar $d55025bea272cdc1$exports = {};\n/**\n * marked v12.0.1 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ (function(global, factory) {\n    factory($d55025bea272cdc1$exports);\n})($d55025bea272cdc1$exports, function(exports1) {\n    \"use strict\";\n    /**\n     * Gets the original marked default options.\n     */ function _getDefaults() {\n        return {\n            async: false,\n            breaks: false,\n            extensions: null,\n            gfm: true,\n            hooks: null,\n            pedantic: false,\n            renderer: null,\n            silent: false,\n            tokenizer: null,\n            walkTokens: null\n        };\n    }\n    exports1.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n        exports1.defaults = newDefaults;\n    }\n    /**\n     * Helpers\n     */ const escapeTest = /[&<>\"']/;\n    const escapeReplace = new RegExp(escapeTest.source, \"g\");\n    const escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\n    const escapeReplacements = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n    };\n    const getEscapeReplacement = (ch)=>escapeReplacements[ch];\n    function escape$1(html, encode) {\n        if (encode) {\n            if (escapeTest.test(html)) return html.replace(escapeReplace, getEscapeReplacement);\n        } else {\n            if (escapeTestNoEncode.test(html)) return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n        return html;\n    }\n    const unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n    function unescape(html) {\n        // explicitly match decimal, hex, and named HTML entities\n        return html.replace(unescapeTest, (_, n)=>{\n            n = n.toLowerCase();\n            if (n === \"colon\") return \":\";\n            if (n.charAt(0) === \"#\") return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n            return \"\";\n        });\n    }\n    const caret = /(^|[^\\[])\\^/g;\n    function edit(regex, opt) {\n        let source = typeof regex === \"string\" ? regex : regex.source;\n        opt = opt || \"\";\n        const obj = {\n            replace: (name, val)=>{\n                let valSource = typeof val === \"string\" ? val : val.source;\n                valSource = valSource.replace(caret, \"$1\");\n                source = source.replace(name, valSource);\n                return obj;\n            },\n            getRegex: ()=>{\n                return new RegExp(source, opt);\n            }\n        };\n        return obj;\n    }\n    function cleanUrl(href) {\n        try {\n            href = encodeURI(href).replace(/%25/g, \"%\");\n        } catch (e) {\n            return null;\n        }\n        return href;\n    }\n    const noopTest = {\n        exec: ()=>null\n    };\n    function splitCells(tableRow, count) {\n        // ensure that every cell-delimiting pipe has a space\n        // before it to distinguish it from an escaped pipe\n        const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n            let escaped = false;\n            let curr = offset;\n            while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n            if (escaped) // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n            else // add space before unescaped |\n            return \" |\";\n        }), cells = row.split(/ \\|/);\n        let i = 0;\n        // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n        if (!cells[0].trim()) cells.shift();\n        if (cells.length > 0 && !cells[cells.length - 1].trim()) cells.pop();\n        if (count) {\n            if (cells.length > count) cells.splice(count);\n            else while(cells.length < count)cells.push(\"\");\n        }\n        for(; i < cells.length; i++)// leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n        return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */ function rtrim(str, c, invert) {\n        const l = str.length;\n        if (l === 0) return \"\";\n        // Length of suffix matching the invert condition.\n        let suffLen = 0;\n        // Step left until we fail to match the invert condition.\n        while(suffLen < l){\n            const currChar = str.charAt(l - suffLen - 1);\n            if (currChar === c && !invert) suffLen++;\n            else if (currChar !== c && invert) suffLen++;\n            else break;\n        }\n        return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n        if (str.indexOf(b[1]) === -1) return -1;\n        let level = 0;\n        for(let i = 0; i < str.length; i++){\n            if (str[i] === \"\\\\\") i++;\n            else if (str[i] === b[0]) level++;\n            else if (str[i] === b[1]) {\n                level--;\n                if (level < 0) return i;\n            }\n        }\n        return -1;\n    }\n    function outputLink(cap, link, raw, lexer) {\n        const href = link.href;\n        const title = link.title ? escape$1(link.title) : null;\n        const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n        if (cap[0].charAt(0) !== \"!\") {\n            lexer.state.inLink = true;\n            const token = {\n                type: \"link\",\n                raw: raw,\n                href: href,\n                title: title,\n                text: text,\n                tokens: lexer.inlineTokens(text)\n            };\n            lexer.state.inLink = false;\n            return token;\n        }\n        return {\n            type: \"image\",\n            raw: raw,\n            href: href,\n            title: title,\n            text: escape$1(text)\n        };\n    }\n    function indentCodeCompensation(raw, text) {\n        const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n        if (matchIndentToCode === null) return text;\n        const indentToCode = matchIndentToCode[1];\n        return text.split(\"\\n\").map((node)=>{\n            const matchIndentInNode = node.match(/^\\s+/);\n            if (matchIndentInNode === null) return node;\n            const [indentInNode] = matchIndentInNode;\n            if (indentInNode.length >= indentToCode.length) return node.slice(indentToCode.length);\n            return node;\n        }).join(\"\\n\");\n    }\n    /**\n     * Tokenizer\n     */ class _Tokenizer {\n        options;\n        rules;\n        lexer;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        space(src) {\n            const cap = this.rules.block.newline.exec(src);\n            if (cap && cap[0].length > 0) return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n        code(src) {\n            const cap = this.rules.block.code.exec(src);\n            if (cap) {\n                const text = cap[0].replace(/^ {1,4}/gm, \"\");\n                return {\n                    type: \"code\",\n                    raw: cap[0],\n                    codeBlockStyle: \"indented\",\n                    text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n                };\n            }\n        }\n        fences(src) {\n            const cap = this.rules.block.fences.exec(src);\n            if (cap) {\n                const raw = cap[0];\n                const text = indentCodeCompensation(raw, cap[3] || \"\");\n                return {\n                    type: \"code\",\n                    raw: raw,\n                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n                    text: text\n                };\n            }\n        }\n        heading(src) {\n            const cap = this.rules.block.heading.exec(src);\n            if (cap) {\n                let text = cap[2].trim();\n                // remove trailing #s\n                if (/#$/.test(text)) {\n                    const trimmed = rtrim(text, \"#\");\n                    if (this.options.pedantic) text = trimmed.trim();\n                    else if (!trimmed || / $/.test(trimmed)) // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n                return {\n                    type: \"heading\",\n                    raw: cap[0],\n                    depth: cap[1].length,\n                    text: text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        hr(src) {\n            const cap = this.rules.block.hr.exec(src);\n            if (cap) return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n        blockquote(src) {\n            const cap = this.rules.block.blockquote.exec(src);\n            if (cap) {\n                const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, \"\"), \"\\n\");\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                const tokens = this.lexer.blockTokens(text);\n                this.lexer.state.top = top;\n                return {\n                    type: \"blockquote\",\n                    raw: cap[0],\n                    tokens: tokens,\n                    text: text\n                };\n            }\n        }\n        list(src) {\n            let cap = this.rules.block.list.exec(src);\n            if (cap) {\n                let bull = cap[1].trim();\n                const isordered = bull.length > 1;\n                const list = {\n                    type: \"list\",\n                    raw: \"\",\n                    ordered: isordered,\n                    start: isordered ? +bull.slice(0, -1) : \"\",\n                    loose: false,\n                    items: []\n                };\n                bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n                if (this.options.pedantic) bull = isordered ? bull : \"[*+-]\";\n                // Get next list item\n                const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n                let raw = \"\";\n                let itemContents = \"\";\n                let endsWithBlankLine = false;\n                // Check if current bullet point can start a new List Item\n                while(src){\n                    let endEarly = false;\n                    if (!(cap = itemRegex.exec(src))) break;\n                    if (this.rules.block.hr.test(src)) break;\n                    raw = cap[0];\n                    src = src.substring(raw.length);\n                    let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                    let nextLine = src.split(\"\\n\", 1)[0];\n                    let indent = 0;\n                    if (this.options.pedantic) {\n                        indent = 2;\n                        itemContents = line.trimStart();\n                    } else {\n                        indent = cap[2].search(/[^ ]/); // Find first non-space char\n                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                        itemContents = line.slice(indent);\n                        indent += cap[1].length;\n                    }\n                    let blankLine = false;\n                    if (!line && /^ *$/.test(nextLine)) {\n                        raw += nextLine + \"\\n\";\n                        src = src.substring(nextLine.length + 1);\n                        endEarly = true;\n                    }\n                    if (!endEarly) {\n                        const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                        const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                        const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                        const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                        // Check if following lines should be included in List Item\n                        while(src){\n                            const rawLine = src.split(\"\\n\", 1)[0];\n                            nextLine = rawLine;\n                            // Re-align to follow commonmark nesting rules\n                            if (this.options.pedantic) nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                            // End list item if found code fences\n                            if (fencesBeginRegex.test(nextLine)) break;\n                            // End list item if found start of new heading\n                            if (headingBeginRegex.test(nextLine)) break;\n                            // End list item if found start of new bullet\n                            if (nextBulletRegex.test(nextLine)) break;\n                            // Horizontal rule found\n                            if (hrRegex.test(src)) break;\n                            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) itemContents += \"\\n\" + nextLine.slice(indent);\n                            else {\n                                // not enough indentation\n                                if (blankLine) break;\n                                // paragraph continuation unless last line was a different block level element\n                                if (line.search(/[^ ]/) >= 4) break;\n                                if (fencesBeginRegex.test(line)) break;\n                                if (headingBeginRegex.test(line)) break;\n                                if (hrRegex.test(line)) break;\n                                itemContents += \"\\n\" + nextLine;\n                            }\n                            if (!blankLine && !nextLine.trim()) blankLine = true;\n                            raw += rawLine + \"\\n\";\n                            src = src.substring(rawLine.length + 1);\n                            line = nextLine.slice(indent);\n                        }\n                    }\n                    if (!list.loose) {\n                        // If the previous item ended with a blank line, the list is loose\n                        if (endsWithBlankLine) list.loose = true;\n                        else if (/\\n *\\n *$/.test(raw)) endsWithBlankLine = true;\n                    }\n                    let istask = null;\n                    let ischecked;\n                    // Check for task list items\n                    if (this.options.gfm) {\n                        istask = /^\\[[ xX]\\] /.exec(itemContents);\n                        if (istask) {\n                            ischecked = istask[0] !== \"[ ] \";\n                            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                        }\n                    }\n                    list.items.push({\n                        type: \"list_item\",\n                        raw: raw,\n                        task: !!istask,\n                        checked: ischecked,\n                        loose: false,\n                        text: itemContents,\n                        tokens: []\n                    });\n                    list.raw += raw;\n                }\n                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n                list.items[list.items.length - 1].raw = raw.trimEnd();\n                list.items[list.items.length - 1].text = itemContents.trimEnd();\n                list.raw = list.raw.trimEnd();\n                // Item child tokens handled here at end because we needed to have the final item to trim it first\n                for(let i = 0; i < list.items.length; i++){\n                    this.lexer.state.top = false;\n                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                    if (!list.loose) {\n                        // Check if list should be loose\n                        const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                        list.loose = hasMultipleLineBreaks;\n                    }\n                }\n                // Set all items to loose if list is loose\n                if (list.loose) for(let i = 0; i < list.items.length; i++)list.items[i].loose = true;\n                return list;\n            }\n        }\n        html(src) {\n            const cap = this.rules.block.html.exec(src);\n            if (cap) {\n                const token = {\n                    type: \"html\",\n                    block: true,\n                    raw: cap[0],\n                    pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                    text: cap[0]\n                };\n                return token;\n            }\n        }\n        def(src) {\n            const cap = this.rules.block.def.exec(src);\n            if (cap) {\n                const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n                const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n                return {\n                    type: \"def\",\n                    tag: tag,\n                    raw: cap[0],\n                    href: href,\n                    title: title\n                };\n            }\n        }\n        table(src) {\n            const cap = this.rules.block.table.exec(src);\n            if (!cap) return;\n            if (!/[:|]/.test(cap[2])) // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n            const headers = splitCells(cap[1]);\n            const aligns = cap[2].replace(/^\\||\\| *$/g, \"\").split(\"|\");\n            const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : [];\n            const item = {\n                type: \"table\",\n                raw: cap[0],\n                header: [],\n                align: [],\n                rows: []\n            };\n            if (headers.length !== aligns.length) // header and align columns must be equal, rows can be different.\n            return;\n            for (const align of aligns){\n                if (/^ *-+: *$/.test(align)) item.align.push(\"right\");\n                else if (/^ *:-+: *$/.test(align)) item.align.push(\"center\");\n                else if (/^ *:-+ *$/.test(align)) item.align.push(\"left\");\n                else item.align.push(null);\n            }\n            for (const header of headers)item.header.push({\n                text: header,\n                tokens: this.lexer.inline(header)\n            });\n            for (const row of rows)item.rows.push(splitCells(row, item.header.length).map((cell)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell)\n                };\n            }));\n            return item;\n        }\n        lheading(src) {\n            const cap = this.rules.block.lheading.exec(src);\n            if (cap) return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n        paragraph(src) {\n            const cap = this.rules.block.paragraph.exec(src);\n            if (cap) {\n                const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n                return {\n                    type: \"paragraph\",\n                    raw: cap[0],\n                    text: text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        text(src) {\n            const cap = this.rules.block.text.exec(src);\n            if (cap) return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n        escape(src) {\n            const cap = this.rules.inline.escape.exec(src);\n            if (cap) return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape$1(cap[1])\n            };\n        }\n        tag(src) {\n            const cap = this.rules.inline.tag.exec(src);\n            if (cap) {\n                if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) this.lexer.state.inLink = true;\n                else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) this.lexer.state.inLink = false;\n                if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) this.lexer.state.inRawBlock = true;\n                else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) this.lexer.state.inRawBlock = false;\n                return {\n                    type: \"html\",\n                    raw: cap[0],\n                    inLink: this.lexer.state.inLink,\n                    inRawBlock: this.lexer.state.inRawBlock,\n                    block: false,\n                    text: cap[0]\n                };\n            }\n        }\n        link(src) {\n            const cap = this.rules.inline.link.exec(src);\n            if (cap) {\n                const trimmedUrl = cap[2].trim();\n                if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                    // commonmark requires matching angle brackets\n                    if (!/>$/.test(trimmedUrl)) return;\n                    // ending angle bracket cannot be escaped\n                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) return;\n                } else {\n                    // find closing parenthesis\n                    const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                    if (lastParenIndex > -1) {\n                        const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                        const linkLen = start + cap[1].length + lastParenIndex;\n                        cap[2] = cap[2].substring(0, lastParenIndex);\n                        cap[0] = cap[0].substring(0, linkLen).trim();\n                        cap[3] = \"\";\n                    }\n                }\n                let href = cap[2];\n                let title = \"\";\n                if (this.options.pedantic) {\n                    // split pedantic href and title\n                    const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                    if (link) {\n                        href = link[1];\n                        title = link[3];\n                    }\n                } else title = cap[3] ? cap[3].slice(1, -1) : \"\";\n                href = href.trim();\n                if (/^</.test(href)) {\n                    if (this.options.pedantic && !/>$/.test(trimmedUrl)) // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                    else href = href.slice(1, -1);\n                }\n                return outputLink(cap, {\n                    href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n                    title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n                }, cap[0], this.lexer);\n            }\n        }\n        reflink(src, links) {\n            let cap;\n            if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n                const linkString = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n                const link = links[linkString.toLowerCase()];\n                if (!link) {\n                    const text = cap[0].charAt(0);\n                    return {\n                        type: \"text\",\n                        raw: text,\n                        text: text\n                    };\n                }\n                return outputLink(cap, link, cap[0], this.lexer);\n            }\n        }\n        emStrong(src, maskedSrc, prevChar = \"\") {\n            let match = this.rules.inline.emStrongLDelim.exec(src);\n            if (!match) return;\n            // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n            if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n            const nextChar = match[1] || match[2] || \"\";\n            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n                const lLength = [\n                    ...match[0]\n                ].length - 1;\n                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n                const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                endReg.lastIndex = 0;\n                // Clip maskedSrc to same section of string as src (move to lexer?)\n                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n                while((match = endReg.exec(maskedSrc)) != null){\n                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                    if (!rDelim) continue; // skip single * in __abc*abc__\n                    rLength = [\n                        ...rDelim\n                    ].length;\n                    if (match[3] || match[4]) {\n                        delimTotal += rLength;\n                        continue;\n                    } else if (match[5] || match[6]) {\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                    delimTotal -= rLength;\n                    if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                    // Remove extra characters. *a*** -> *a*\n                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                    // char length can be >1 for unicode characters;\n                    const lastCharLength = [\n                        ...match[0]\n                    ][0].length;\n                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                    // Create `em` if smallest delimiter has odd char count. *a***\n                    if (Math.min(lLength, rLength) % 2) {\n                        const text = raw.slice(1, -1);\n                        return {\n                            type: \"em\",\n                            raw: raw,\n                            text: text,\n                            tokens: this.lexer.inlineTokens(text)\n                        };\n                    }\n                    // Create 'strong' if smallest delimiter has even char count. **a***\n                    const text = raw.slice(2, -2);\n                    return {\n                        type: \"strong\",\n                        raw: raw,\n                        text: text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n            }\n        }\n        codespan(src) {\n            const cap = this.rules.inline.code.exec(src);\n            if (cap) {\n                let text = cap[2].replace(/\\n/g, \" \");\n                const hasNonSpaceChars = /[^ ]/.test(text);\n                const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) text = text.substring(1, text.length - 1);\n                text = escape$1(text, true);\n                return {\n                    type: \"codespan\",\n                    raw: cap[0],\n                    text: text\n                };\n            }\n        }\n        br(src) {\n            const cap = this.rules.inline.br.exec(src);\n            if (cap) return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n        del(src) {\n            const cap = this.rules.inline.del.exec(src);\n            if (cap) return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n        autolink(src) {\n            const cap = this.rules.inline.autolink.exec(src);\n            if (cap) {\n                let text, href;\n                if (cap[2] === \"@\") {\n                    text = escape$1(cap[1]);\n                    href = \"mailto:\" + text;\n                } else {\n                    text = escape$1(cap[1]);\n                    href = text;\n                }\n                return {\n                    type: \"link\",\n                    raw: cap[0],\n                    text: text,\n                    href: href,\n                    tokens: [\n                        {\n                            type: \"text\",\n                            raw: text,\n                            text: text\n                        }\n                    ]\n                };\n            }\n        }\n        url(src) {\n            let cap;\n            if (cap = this.rules.inline.url.exec(src)) {\n                let text, href;\n                if (cap[2] === \"@\") {\n                    text = escape$1(cap[0]);\n                    href = \"mailto:\" + text;\n                } else {\n                    // do extended autolink path validation\n                    let prevCapZero;\n                    do {\n                        prevCapZero = cap[0];\n                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? \"\";\n                    }while (prevCapZero !== cap[0]);\n                    text = escape$1(cap[0]);\n                    if (cap[1] === \"www.\") href = \"http://\" + cap[0];\n                    else href = cap[0];\n                }\n                return {\n                    type: \"link\",\n                    raw: cap[0],\n                    text: text,\n                    href: href,\n                    tokens: [\n                        {\n                            type: \"text\",\n                            raw: text,\n                            text: text\n                        }\n                    ]\n                };\n            }\n        }\n        inlineText(src) {\n            const cap = this.rules.inline.text.exec(src);\n            if (cap) {\n                let text;\n                if (this.lexer.state.inRawBlock) text = cap[0];\n                else text = escape$1(cap[0]);\n                return {\n                    type: \"text\",\n                    raw: cap[0],\n                    text: text\n                };\n            }\n        }\n    }\n    /**\n     * Block-Level Grammar\n     */ const newline = /^(?: *(?:\\n|$))+/;\n    const blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/).replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\n    const _tag = \"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul\";\n    const _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n    const html = edit(\"^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$))\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n    const paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n    .replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\n    /**\n     * Normal Block Grammar\n     */ const blockNormal = {\n        blockquote: blockquote,\n        code: blockCode,\n        def: def,\n        fences: fences,\n        heading: heading,\n        hr: hr,\n        html: html,\n        lheading: lheading,\n        list: list,\n        newline: newline,\n        paragraph: paragraph,\n        table: noopTest,\n        text: blockText\n    };\n    /**\n     * GFM Block Grammar\n     */ const gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\") // Cells\n    .replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockGfm = {\n        ...blockNormal,\n        table: gfmTable,\n        paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n        .replace(\"table\", gfmTable) // interrupt paragraphs with table\n        .replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n        .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex()\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */ const blockPedantic = {\n        ...blockNormal,\n        html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest,\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n    };\n    /**\n     * Inline-Level Grammar\n     */ const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = \"\\\\p{P}\\\\p{S}\";\n    const punctuation = edit(/^((?![*_])[\\spunctuation])/, \"u\").replace(/punctuation/g, _punctuation).getRegex();\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, \"u\").replace(/punct/g, _punctuation).getRegex();\n    const emStrongRDelimAst = edit(\"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])\", \"gu\") // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation).getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\\\s]|$)|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])|[\\\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])\", \"gu\") // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation).getRegex();\n    const anyPunctuation = edit(/\\\\([punct])/, \"gu\").replace(/punct/g, _punctuation).getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\n    const _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\n    const tag = edit(\"^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\") // CDATA section\n    .replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\n    const reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\n    /**\n     * Normal Inline Grammar\n     */ const inlineNormal = {\n        _backpedal: noopTest,\n        anyPunctuation: anyPunctuation,\n        autolink: autolink,\n        blockSkip: blockSkip,\n        br: br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim: emStrongLDelim,\n        emStrongRDelimAst: emStrongRDelimAst,\n        emStrongRDelimUnd: emStrongRDelimUnd,\n        escape: escape,\n        link: link,\n        nolink: nolink,\n        punctuation: punctuation,\n        reflink: reflink,\n        reflinkSearch: reflinkSearch,\n        tag: tag,\n        text: inlineText,\n        url: noopTest\n    };\n    /**\n     * Pedantic Inline Grammar\n     */ const inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n    };\n    /**\n     * GFM Inline Grammar\n     */ const inlineGfm = {\n        ...inlineNormal,\n        escape: edit(escape).replace(\"])\", \"~|])\").getRegex(),\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */ const inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n        text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n    };\n    /**\n     * exports\n     */ const block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic\n    };\n    const inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic\n    };\n    /**\n     * Block Lexer\n     */ class _Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options){\n            // TokenList cannot be created in one go\n            this.tokens = [];\n            this.tokens.links = Object.create(null);\n            this.options = options || exports1.defaults;\n            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n            this.tokenizer = this.options.tokenizer;\n            this.tokenizer.options = this.options;\n            this.tokenizer.lexer = this;\n            this.inlineQueue = [];\n            this.state = {\n                inLink: false,\n                inRawBlock: false,\n                top: true\n            };\n            const rules = {\n                block: block.normal,\n                inline: inline.normal\n            };\n            if (this.options.pedantic) {\n                rules.block = block.pedantic;\n                rules.inline = inline.pedantic;\n            } else if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) rules.inline = inline.breaks;\n                else rules.inline = inline.gfm;\n            }\n            this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */ static get rules() {\n            return {\n                block: block,\n                inline: inline\n            };\n        }\n        /**\n         * Static Lex Method\n         */ static lex(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */ static lexInline(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */ lex(src) {\n            src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n            this.blockTokens(src, this.tokens);\n            for(let i = 0; i < this.inlineQueue.length; i++){\n                const next = this.inlineQueue[i];\n                this.inlineTokens(next.src, next.tokens);\n            }\n            this.inlineQueue = [];\n            return this.tokens;\n        }\n        blockTokens(src, tokens = []) {\n            if (this.options.pedantic) src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n            else src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs)=>{\n                return leading + \"    \".repeat(tabs.length);\n            });\n            let token;\n            let lastToken;\n            let cutSrc;\n            let lastParagraphClipped;\n            while(src){\n                if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                    if (token = extTokenizer.call({\n                        lexer: this\n                    }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) continue;\n                // newline\n                if (token = this.tokenizer.space(src)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.length === 1 && tokens.length > 0) // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                    else tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.code(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    // An indented code block cannot interrupt a paragraph.\n                    if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // fences\n                if (token = this.tokenizer.fences(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // heading\n                if (token = this.tokenizer.heading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // hr\n                if (token = this.tokenizer.hr(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // blockquote\n                if (token = this.tokenizer.blockquote(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // list\n                if (token = this.tokenizer.list(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // html\n                if (token = this.tokenizer.html(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // def\n                if (token = this.tokenizer.def(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.raw;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else if (!this.tokens.links[token.tag]) this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                    continue;\n                }\n                // table (gfm)\n                if (token = this.tokenizer.table(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // lheading\n                if (token = this.tokenizer.lheading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // top-level paragraph\n                // prevent paragraph consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startBlock) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);\n                }\n                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    lastParagraphClipped = cutSrc.length !== src.length;\n                    src = src.substring(token.raw.length);\n                    continue;\n                }\n                // text\n                if (token = this.tokenizer.text(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === \"text\") {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                if (src) {\n                    const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    } else throw new Error(errMsg);\n                }\n            }\n            this.state.top = true;\n            return tokens;\n        }\n        inline(src, tokens = []) {\n            this.inlineQueue.push({\n                src: src,\n                tokens: tokens\n            });\n            return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */ inlineTokens(src, tokens = []) {\n            let token, lastToken, cutSrc;\n            // String with links masked to avoid interference with em and strong\n            let maskedSrc = src;\n            let match;\n            let keepPrevChar, prevChar;\n            // Mask out reflinks\n            if (this.tokens.links) {\n                const links = Object.keys(this.tokens.links);\n                if (links.length > 0) {\n                    while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null)if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                }\n            }\n            // Mask out other blocks\n            while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null)maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            // Mask out escaped characters\n            while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null)maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            while(src){\n                if (!keepPrevChar) prevChar = \"\";\n                keepPrevChar = false;\n                // extensions\n                if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                    if (token = extTokenizer.call({\n                        lexer: this\n                    }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) continue;\n                // escape\n                if (token = this.tokenizer.escape(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // tag\n                if (token = this.tokenizer.tag(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // link\n                if (token = this.tokenizer.link(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // reflink, nolink\n                if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // em & strong\n                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.codespan(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // br\n                if (token = this.tokenizer.br(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // del (gfm)\n                if (token = this.tokenizer.del(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // autolink\n                if (token = this.tokenizer.autolink(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // url (gfm)\n                if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // text\n                // prevent inlineText consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startInline) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startInline.forEach((getStartIndex)=>{\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);\n                }\n                if (token = this.tokenizer.inlineText(cutSrc)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.slice(-1) !== \"_\") prevChar = token.raw.slice(-1);\n                    keepPrevChar = true;\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                if (src) {\n                    const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    } else throw new Error(errMsg);\n                }\n            }\n            return tokens;\n        }\n    }\n    /**\n     * Renderer\n     */ class _Renderer {\n        options;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        code(code, infostring, escaped) {\n            const lang = (infostring || \"\").match(/^\\S*/)?.[0];\n            code = code.replace(/\\n$/, \"\") + \"\\n\";\n            if (!lang) return \"<pre><code>\" + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n            return '<pre><code class=\"language-' + escape$1(lang) + '\">' + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n        }\n        blockquote(quote) {\n            return `<blockquote>\\n${quote}</blockquote>\\n`;\n        }\n        html(html, block) {\n            return html;\n        }\n        heading(text, level, raw) {\n            // ignore IDs\n            return `<h${level}>${text}</h${level}>\\n`;\n        }\n        hr() {\n            return \"<hr>\\n\";\n        }\n        list(body, ordered, start) {\n            const type = ordered ? \"ol\" : \"ul\";\n            const startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n            return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n        }\n        listitem(text, task, checked) {\n            return `<li>${text}</li>\\n`;\n        }\n        checkbox(checked) {\n            return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph(text) {\n            return `<p>${text}</p>\\n`;\n        }\n        table(header, body) {\n            if (body) body = `<tbody>${body}</tbody>`;\n            return \"<table>\\n<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n        }\n        tablerow(content) {\n            return `<tr>\\n${content}</tr>\\n`;\n        }\n        tablecell(content, flags) {\n            const type = flags.header ? \"th\" : \"td\";\n            const tag = flags.align ? `<${type} align=\"${flags.align}\">` : `<${type}>`;\n            return tag + content + `</${type}>\\n`;\n        }\n        /**\n         * span level renderer\n         */ strong(text) {\n            return `<strong>${text}</strong>`;\n        }\n        em(text) {\n            return `<em>${text}</em>`;\n        }\n        codespan(text) {\n            return `<code>${text}</code>`;\n        }\n        br() {\n            return \"<br>\";\n        }\n        del(text) {\n            return `<del>${text}</del>`;\n        }\n        link(href, title, text) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) return text;\n            href = cleanHref;\n            let out = '<a href=\"' + href + '\"';\n            if (title) out += ' title=\"' + title + '\"';\n            out += \">\" + text + \"</a>\";\n            return out;\n        }\n        image(href, title, text) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) return text;\n            href = cleanHref;\n            let out = `<img src=\"${href}\" alt=\"${text}\"`;\n            if (title) out += ` title=\"${title}\"`;\n            out += \">\";\n            return out;\n        }\n        text(text) {\n            return text;\n        }\n    }\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */ class _TextRenderer {\n        // no need for block level renderers\n        strong(text) {\n            return text;\n        }\n        em(text) {\n            return text;\n        }\n        codespan(text) {\n            return text;\n        }\n        del(text) {\n            return text;\n        }\n        html(text) {\n            return text;\n        }\n        text(text) {\n            return text;\n        }\n        link(href, title, text) {\n            return \"\" + text;\n        }\n        image(href, title, text) {\n            return \"\" + text;\n        }\n        br() {\n            return \"\";\n        }\n    }\n    /**\n     * Parsing & Compiling\n     */ class _Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options){\n            this.options = options || exports1.defaults;\n            this.options.renderer = this.options.renderer || new _Renderer();\n            this.renderer = this.options.renderer;\n            this.renderer.options = this.options;\n            this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */ static parse(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */ static parseInline(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */ parse(tokens, top = true) {\n            let out = \"\";\n            for(let i = 0; i < tokens.length; i++){\n                const token = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                    const genericToken = token;\n                    const ret = this.options.extensions.renderers[genericToken.type].call({\n                        parser: this\n                    }, genericToken);\n                    if (ret !== false || ![\n                        \"space\",\n                        \"hr\",\n                        \"heading\",\n                        \"code\",\n                        \"table\",\n                        \"blockquote\",\n                        \"list\",\n                        \"html\",\n                        \"paragraph\",\n                        \"text\"\n                    ].includes(genericToken.type)) {\n                        out += ret || \"\";\n                        continue;\n                    }\n                }\n                switch(token.type){\n                    case \"space\":\n                        continue;\n                    case \"hr\":\n                        out += this.renderer.hr();\n                        continue;\n                    case \"heading\":\n                        {\n                            const headingToken = token;\n                            out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                            continue;\n                        }\n                    case \"code\":\n                        {\n                            const codeToken = token;\n                            out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                            continue;\n                        }\n                    case \"table\":\n                        {\n                            const tableToken = token;\n                            let header = \"\";\n                            // header\n                            let cell = \"\";\n                            for(let j = 0; j < tableToken.header.length; j++)cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), {\n                                header: true,\n                                align: tableToken.align[j]\n                            });\n                            header += this.renderer.tablerow(cell);\n                            let body = \"\";\n                            for(let j = 0; j < tableToken.rows.length; j++){\n                                const row = tableToken.rows[j];\n                                cell = \"\";\n                                for(let k = 0; k < row.length; k++)cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: tableToken.align[k]\n                                });\n                                body += this.renderer.tablerow(cell);\n                            }\n                            out += this.renderer.table(header, body);\n                            continue;\n                        }\n                    case \"blockquote\":\n                        {\n                            const blockquoteToken = token;\n                            const body = this.parse(blockquoteToken.tokens);\n                            out += this.renderer.blockquote(body);\n                            continue;\n                        }\n                    case \"list\":\n                        {\n                            const listToken = token;\n                            const ordered = listToken.ordered;\n                            const start = listToken.start;\n                            const loose = listToken.loose;\n                            let body = \"\";\n                            for(let j = 0; j < listToken.items.length; j++){\n                                const item = listToken.items[j];\n                                const checked = item.checked;\n                                const task = item.task;\n                                let itemBody = \"\";\n                                if (item.task) {\n                                    const checkbox = this.renderer.checkbox(!!checked);\n                                    if (loose) {\n                                        if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                            item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                            if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        } else item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox + \" \"\n                                        });\n                                    } else itemBody += checkbox + \" \";\n                                }\n                                itemBody += this.parse(item.tokens, loose);\n                                body += this.renderer.listitem(itemBody, task, !!checked);\n                            }\n                            out += this.renderer.list(body, ordered, start);\n                            continue;\n                        }\n                    case \"html\":\n                        {\n                            const htmlToken = token;\n                            out += this.renderer.html(htmlToken.text, htmlToken.block);\n                            continue;\n                        }\n                    case \"paragraph\":\n                        {\n                            const paragraphToken = token;\n                            out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                            continue;\n                        }\n                    case \"text\":\n                        {\n                            let textToken = token;\n                            let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                            while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                                textToken = tokens[++i];\n                                body += \"\\n\" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                            }\n                            out += top ? this.renderer.paragraph(body) : body;\n                            continue;\n                        }\n                    default:\n                        {\n                            const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                            if (this.options.silent) {\n                                console.error(errMsg);\n                                return \"\";\n                            } else throw new Error(errMsg);\n                        }\n                }\n            }\n            return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */ parseInline(tokens, renderer) {\n            renderer = renderer || this.renderer;\n            let out = \"\";\n            for(let i = 0; i < tokens.length; i++){\n                const token = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                    const ret = this.options.extensions.renderers[token.type].call({\n                        parser: this\n                    }, token);\n                    if (ret !== false || ![\n                        \"escape\",\n                        \"html\",\n                        \"link\",\n                        \"image\",\n                        \"strong\",\n                        \"em\",\n                        \"codespan\",\n                        \"br\",\n                        \"del\",\n                        \"text\"\n                    ].includes(token.type)) {\n                        out += ret || \"\";\n                        continue;\n                    }\n                }\n                switch(token.type){\n                    case \"escape\":\n                        {\n                            const escapeToken = token;\n                            out += renderer.text(escapeToken.text);\n                            break;\n                        }\n                    case \"html\":\n                        {\n                            const tagToken = token;\n                            out += renderer.html(tagToken.text);\n                            break;\n                        }\n                    case \"link\":\n                        {\n                            const linkToken = token;\n                            out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                            break;\n                        }\n                    case \"image\":\n                        {\n                            const imageToken = token;\n                            out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                            break;\n                        }\n                    case \"strong\":\n                        {\n                            const strongToken = token;\n                            out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                            break;\n                        }\n                    case \"em\":\n                        {\n                            const emToken = token;\n                            out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                            break;\n                        }\n                    case \"codespan\":\n                        {\n                            const codespanToken = token;\n                            out += renderer.codespan(codespanToken.text);\n                            break;\n                        }\n                    case \"br\":\n                        out += renderer.br();\n                        break;\n                    case \"del\":\n                        {\n                            const delToken = token;\n                            out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            const textToken = token;\n                            out += renderer.text(textToken.text);\n                            break;\n                        }\n                    default:\n                        {\n                            const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                            if (this.options.silent) {\n                                console.error(errMsg);\n                                return \"\";\n                            } else throw new Error(errMsg);\n                        }\n                }\n            }\n            return out;\n        }\n    }\n    class _Hooks {\n        options;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        static passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\",\n            \"processAllTokens\"\n        ]);\n        /**\n         * Process markdown before marked\n         */ preprocess(markdown) {\n            return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */ postprocess(html) {\n            return html;\n        }\n        /**\n         * Process all tokens before walk tokens\n         */ processAllTokens(tokens) {\n            return tokens;\n        }\n    }\n    class Marked {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args){\n            this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */ walkTokens(tokens, callback) {\n            let values = [];\n            for (const token of tokens){\n                values = values.concat(callback.call(this, token));\n                switch(token.type){\n                    case \"table\":\n                        {\n                            const tableToken = token;\n                            for (const cell of tableToken.header)values = values.concat(this.walkTokens(cell.tokens, callback));\n                            for (const row of tableToken.rows)for (const cell of row)values = values.concat(this.walkTokens(cell.tokens, callback));\n                            break;\n                        }\n                    case \"list\":\n                        {\n                            const listToken = token;\n                            values = values.concat(this.walkTokens(listToken.items, callback));\n                            break;\n                        }\n                    default:\n                        {\n                            const genericToken = token;\n                            if (this.defaults.extensions?.childTokens?.[genericToken.type]) this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                            else if (genericToken.tokens) values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                }\n            }\n            return values;\n        }\n        use(...args) {\n            const extensions = this.defaults.extensions || {\n                renderers: {},\n                childTokens: {}\n            };\n            args.forEach((pack)=>{\n                // copy options to new object\n                const opts = {\n                    ...pack\n                };\n                // set async to true if it was set to true before\n                opts.async = this.defaults.async || opts.async || false;\n                // ==-- Parse \"addon\" extensions --== //\n                if (pack.extensions) {\n                    pack.extensions.forEach((ext)=>{\n                        if (!ext.name) throw new Error(\"extension name required\");\n                        if (\"renderer\" in ext) {\n                            const prevRenderer = extensions.renderers[ext.name];\n                            if (prevRenderer) // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) ret = prevRenderer.apply(this, args);\n                                return ret;\n                            };\n                            else extensions.renderers[ext.name] = ext.renderer;\n                        }\n                        if (\"tokenizer\" in ext) {\n                            if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") throw new Error(\"extension level must be 'block' or 'inline'\");\n                            const extLevel = extensions[ext.level];\n                            if (extLevel) extLevel.unshift(ext.tokenizer);\n                            else extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                            if (ext.start) {\n                                if (ext.level === \"block\") {\n                                    if (extensions.startBlock) extensions.startBlock.push(ext.start);\n                                    else extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                } else if (ext.level === \"inline\") {\n                                    if (extensions.startInline) extensions.startInline.push(ext.start);\n                                    else extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                        if (\"childTokens\" in ext && ext.childTokens) extensions.childTokens[ext.name] = ext.childTokens;\n                    });\n                    opts.extensions = extensions;\n                }\n                // ==-- Parse \"overwrite\" extensions --== //\n                if (pack.renderer) {\n                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                    for(const prop in pack.renderer){\n                        if (!(prop in renderer)) throw new Error(`renderer '${prop}' does not exist`);\n                        if (prop === \"options\") continue;\n                        const rendererProp = prop;\n                        const rendererFunc = pack.renderer[rendererProp];\n                        const prevRenderer = renderer[rendererProp];\n                        // Replace renderer with func to run extension, but fall back if false\n                        renderer[rendererProp] = (...args)=>{\n                            let ret = rendererFunc.apply(renderer, args);\n                            if (ret === false) ret = prevRenderer.apply(renderer, args);\n                            return ret || \"\";\n                        };\n                    }\n                    opts.renderer = renderer;\n                }\n                if (pack.tokenizer) {\n                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                    for(const prop in pack.tokenizer){\n                        if (!(prop in tokenizer)) throw new Error(`tokenizer '${prop}' does not exist`);\n                        if ([\n                            \"options\",\n                            \"rules\",\n                            \"lexer\"\n                        ].includes(prop)) continue;\n                        const tokenizerProp = prop;\n                        const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                        const prevTokenizer = tokenizer[tokenizerProp];\n                        // Replace tokenizer with func to run extension, but fall back if false\n                        // @ts-expect-error cannot type tokenizer function dynamically\n                        tokenizer[tokenizerProp] = (...args)=>{\n                            let ret = tokenizerFunc.apply(tokenizer, args);\n                            if (ret === false) ret = prevTokenizer.apply(tokenizer, args);\n                            return ret;\n                        };\n                    }\n                    opts.tokenizer = tokenizer;\n                }\n                // ==-- Parse Hooks extensions --== //\n                if (pack.hooks) {\n                    const hooks = this.defaults.hooks || new _Hooks();\n                    for(const prop in pack.hooks){\n                        if (!(prop in hooks)) throw new Error(`hook '${prop}' does not exist`);\n                        if (prop === \"options\") continue;\n                        const hooksProp = prop;\n                        const hooksFunc = pack.hooks[hooksProp];\n                        const prevHook = hooks[hooksProp];\n                        if (_Hooks.passThroughHooks.has(prop)) // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                return prevHook.call(hooks, ret);\n                            });\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                        else // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) ret = prevHook.apply(hooks, args);\n                            return ret;\n                        };\n                    }\n                    opts.hooks = hooks;\n                }\n                // ==-- Parse WalkTokens extensions --== //\n                if (pack.walkTokens) {\n                    const walkTokens = this.defaults.walkTokens;\n                    const packWalktokens = pack.walkTokens;\n                    opts.walkTokens = function(token) {\n                        let values = [];\n                        values.push(packWalktokens.call(this, token));\n                        if (walkTokens) values = values.concat(walkTokens.call(this, token));\n                        return values;\n                    };\n                }\n                this.defaults = {\n                    ...this.defaults,\n                    ...opts\n                };\n            });\n            return this;\n        }\n        setOptions(opt) {\n            this.defaults = {\n                ...this.defaults,\n                ...opt\n            };\n            return this;\n        }\n        lexer(src, options) {\n            return _Lexer.lex(src, options ?? this.defaults);\n        }\n        parser(tokens, options) {\n            return _Parser.parse(tokens, options ?? this.defaults);\n        }\n        #parseMarkdown(lexer, parser) {\n            return (src, options)=>{\n                const origOpt = {\n                    ...options\n                };\n                const opt = {\n                    ...this.defaults,\n                    ...origOpt\n                };\n                // Show warning if an extension set async to true but the parse was called with async: false\n                if (this.defaults.async === true && origOpt.async === false) {\n                    if (!opt.silent) console.warn(\"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.\");\n                    opt.async = true;\n                }\n                const throwError = this.#onError(!!opt.silent, !!opt.async);\n                // throw error in case of non string input\n                if (typeof src === \"undefined\" || src === null) return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n                if (typeof src !== \"string\") return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n                if (opt.hooks) opt.hooks.options = opt;\n                if (opt.async) return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n                try {\n                    if (opt.hooks) src = opt.hooks.preprocess(src);\n                    let tokens = lexer(src, opt);\n                    if (opt.hooks) tokens = opt.hooks.processAllTokens(tokens);\n                    if (opt.walkTokens) this.walkTokens(tokens, opt.walkTokens);\n                    let html = parser(tokens, opt);\n                    if (opt.hooks) html = opt.hooks.postprocess(html);\n                    return html;\n                } catch (e) {\n                    return throwError(e);\n                }\n            };\n        }\n        #onError(silent, async) {\n            return (e)=>{\n                e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n                if (silent) {\n                    const msg = \"<p>An error occurred:</p><pre>\" + escape$1(e.message + \"\", true) + \"</pre>\";\n                    if (async) return Promise.resolve(msg);\n                    return msg;\n                }\n                if (async) return Promise.reject(e);\n                throw e;\n            };\n        }\n    }\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n        return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */ marked.options = marked.setOptions = function(options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Gets the original marked default options.\n     */ marked.getDefaults = _getDefaults;\n    marked.defaults = exports1.defaults;\n    /**\n     * Use Extension\n     */ marked.use = function(...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Run callback for every token\n     */ marked.walkTokens = function(tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */ marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */ marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n    exports1.Hooks = _Hooks;\n    exports1.Lexer = _Lexer;\n    exports1.Marked = Marked;\n    exports1.Parser = _Parser;\n    exports1.Renderer = _Renderer;\n    exports1.TextRenderer = _TextRenderer;\n    exports1.Tokenizer = _Tokenizer;\n    exports1.getDefaults = _getDefaults;\n    exports1.lexer = lexer;\n    exports1.marked = marked;\n    exports1.options = options;\n    exports1.parse = parse;\n    exports1.parseInline = parseInline;\n    exports1.parser = parser;\n    exports1.setOptions = setOptions;\n    exports1.use = use;\n    exports1.walkTokens = walkTokens;\n});\n\n\nvar $9f15ba0f573fd662$exports = {};\nvar $1ce53450831f8f67$exports = {};\n$1ce53450831f8f67$exports = new URL(\"assistant.77c3fc48.svg\", import.meta.url).toString();\n\n\nvar $d0a25553bcd569fe$exports = {};\n$d0a25553bcd569fe$exports = new URL(\"user.fb24b6a4.svg\", import.meta.url).toString();\n\n\n$9f15ba0f573fd662$exports = {\n    \"assistant\": $1ce53450831f8f67$exports,\n    \"user\": $d0a25553bcd569fe$exports\n};\n\n\nvar $4acad45e9fe5452d$exports = {};\nvar $40cc52ff9979b2b8$exports = {};\n$40cc52ff9979b2b8$exports = new URL(\"chatgpt.55962a7f.svg\", import.meta.url).toString();\n\n\nvar $afed79c407f4cd19$exports = {};\n$afed79c407f4cd19$exports = new URL(\"gigachat.bbbefb94.svg\", import.meta.url).toString();\n\n\nvar $f8f48c5c67d92034$exports = {};\n$f8f48c5c67d92034$exports = new URL(\"yandexgpt.771714db.svg\", import.meta.url).toString();\n\n\n$4acad45e9fe5452d$exports = {\n    \"chatgpt\": $40cc52ff9979b2b8$exports,\n    \"gigachat\": $afed79c407f4cd19$exports,\n    \"yandexgpt\": $f8f48c5c67d92034$exports\n};\n\n\nconst $d3921e788426b86e$export$698d4a59e5b8dad1 = [\n    {\n        id: \"Nu7w-QeKzc7oKMY4\",\n        title: \"IT Marketing\",\n        description: \"Yet Another IT Marketing\",\n        instruction: \"\\u0422\\u044B - \\u043F\\u0440\\u043E\\u0444\\u0435\\u0441\\u0441\\u0438\\u043E\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 IT-\\u043C\\u0430\\u0440\\u043A\\u0435\\u0442\\u043E\\u043B\\u043E\\u0433\",\n        model: {\n            id: \"yandexgpt-lite\",\n            stream: false,\n            temperature: 0.6,\n            maxTokens: 2000\n        },\n        messages: []\n    },\n    {\n        id: \"8jdCmF7eNGPPZ5Ss\",\n        title: \"\\u041C\\u0435\\u043C\\u043E\\u0434\\u0435\\u043B\",\n        description: \"GigaChat\",\n        instruction: \"\",\n        model: {\n            id: \"GigaChat\",\n            stream: false,\n            temperature: 0.9,\n            maxTokens: 3000\n        },\n        messages: [\n            {\n                text: '\\u041F\\u0440\\u043E\\u0434\\u043E\\u043B\\u0436\\u0438 \\u0430\\u043D\\u0435\\u043A\\u0434\\u043E\\u0442: \"\\u0441\\u0435\\u043B \\u043C\\u0435\\u0434\\u0432\\u0435\\u0434\\u044C \\u0432 \\u043C\\u0430\\u0448\\u0438\\u043D\\u0443 \\u0438...?\"',\n                role: \"user\"\n            },\n            {\n                text: \"\\u0412\\u043E\\u0442 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442\\u043E\\u0432 \\u0442\\u043E\\u0433\\u043E, \\u043A\\u0430\\u043A \\u043C\\u043E\\u0436\\u0435\\u0442 \\u0432\\u044B\\u0433\\u043B\\u044F\\u0434\\u0435\\u0442\\u044C \\u0430\\u043D\\u0435\\u043A\\u0434\\u043E\\u0442:\\n\\n1. \\u0421\\u0435\\u043B \\u043C\\u0435\\u0434\\u0432\\u0435\\u0434\\u044C \\u0432 \\u043C\\u0430\\u0448\\u0438\\u043D\\u0443 \\u0438 \\u043F\\u043E\\u0435\\u0445\\u0430\\u043B \\u043D\\u0430 \\u0440\\u044B\\u0431\\u0430\\u043B\\u043A\\u0443.\\n\\n2. \\u0421\\u0435\\u043B \\u043C\\u0435\\u0434\\u0432\\u0435\\u0434\\u044C \\u0432 \\u043C\\u0430\\u0448\\u0438\\u043D\\u0443 \\u0438 \\u043F\\u043E\\u0435\\u0445\\u0430\\u043B \\u0432 \\u043B\\u0435\\u0441 \\u0437\\u0430 \\u043C\\u0430\\u043B\\u0438\\u043D\\u043E\\u0439.\\n\\n3. \\u0421\\u0435\\u043B \\u043C\\u0435\\u0434\\u0432\\u0435\\u0434\\u044C \\u0432 \\u043C\\u0430\\u0448\\u0438\\u043D\\u0443 \\u0438 \\u043F\\u043E\\u0435\\u0445\\u0430\\u043B \\u0432 \\u0446\\u0438\\u0440\\u043A.\\n\\n4. \\u0421\\u0435\\u043B \\u043C\\u0435\\u0434\\u0432\\u0435\\u0434\\u044C \\u0432 \\u043C\\u0430\\u0448\\u0438\\u043D\\u0443 \\u0438 \\u043F\\u043E\\u0435\\u0445\\u0430\\u043B \\u043D\\u0430 \\u0440\\u0435\\u0447\\u043A\\u0443 \\u043A\\u0443\\u043F\\u0430\\u0442\\u044C\\u0441\\u044F.\",\n                role: \"assistant\"\n            }\n        ]\n    },\n    {\n        id: \"sd0O9o4yFTMIGNN3\",\n        title: \"\\u041C\\u0435\\u0434\\u0438\\u0435\\u0432\\u0438\\u0441\\u0442\",\n        instruction: \"\\u0422\\u044B - \\u043F\\u0440\\u043E\\u0444\\u0435\\u0441\\u0441\\u0438\\u043E\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u043A-\\u043C\\u0435\\u0434\\u0438\\u0435\\u0432\\u0438\\u0441\\u0442\",\n        model: {\n            id: \"GPT-4\",\n            stream: false,\n            temperature: 0.4,\n            maxTokens: 2000\n        },\n        messages: [\n            {\n                text: \"\\u041D\\u0430\\u0437\\u043E\\u0432\\u0438 \\u0442\\u0440\\u0438 \\u0433\\u043B\\u0430\\u0432\\u043D\\u044B\\u0435 \\u043F\\u0440\\u0438\\u0447\\u0438\\u043D\\u044B \\u0432\\u043E\\u0439\\u043D\\u044B \\u0431\\u0435\\u043B\\u043E\\u0439 \\u0438 \\u0430\\u043B\\u043E\\u0439 \\u0440\\u043E\\u0437\\u044B\",\n                role: \"user\"\n            },\n            {\n                text: \"\\u041A\\u0430\\u043A \\u0438\\u0441\\u043A\\u0443\\u0441\\u0441\\u0442\\u0432\\u0435\\u043D\\u043D\\u044B\\u0439 \\u0438\\u043D\\u0442\\u0435\\u043B\\u043B\\u0435\\u043A\\u0442 \\u044F \\u043D\\u0435 \\u043C\\u043E\\u0433\\u0443 \\u0443\\u0442\\u0432\\u0435\\u0440\\u0436\\u0434\\u0430\\u0442\\u044C, \\u0447\\u0442\\u043E \\u043E\\u0431\\u043B\\u0430\\u0434\\u0430\\u044E \\u043F\\u0440\\u043E\\u0444\\u0435\\u0441\\u0441\\u0438\\u043E\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C\\u0438 \\u0437\\u043D\\u0430\\u043D\\u0438\\u044F\\u043C\\u0438 \\u0432 \\u043E\\u0431\\u043B\\u0430\\u0441\\u0442\\u0438 \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0438, \\u0432 \\u0447\\u0430\\u0441\\u0442\\u043D\\u043E\\u0441\\u0442\\u0438, \\u0432 \\u043E\\u0431\\u043B\\u0430\\u0441\\u0442\\u0438 \\u0438\\u0437\\u0443\\u0447\\u0435\\u043D\\u0438\\u044F \\u0432\\u043E\\u0439\\u043D \\u0410\\u043B\\u043E\\u0439 \\u0438 \\u0411\\u0435\\u043B\\u043E\\u0439 \\u0440\\u043E\\u0437\\u044B. \\u041E\\u0434\\u043D\\u0430\\u043A\\u043E \\u044F \\u043C\\u043E\\u0433\\u0443 \\u043F\\u0440\\u0435\\u0434\\u043B\\u043E\\u0436\\u0438\\u0442\\u044C \\u043D\\u0435\\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u0432\\u043E\\u0437\\u043C\\u043E\\u0436\\u043D\\u044B\\u0435 \\u043F\\u0440\\u0438\\u0447\\u0438\\u043D\\u044B \\u044D\\u0442\\u0438\\u0445 \\u0432\\u043E\\u0439\\u043D:\\n\\n1. **\\u0414\\u0438\\u043D\\u0430\\u0441\\u0442\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0439 \\u043A\\u0440\\u0438\\u0437\\u0438\\u0441.** \\u0412\\u043E\\u0439\\u043D\\u044B \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438\\u0441\\u044C \\u0438\\u0437-\\u0437\\u0430 \\u0434\\u0438\\u043D\\u0430\\u0441\\u0442\\u0438\\u0447\\u0435\\u0441\\u043A\\u043E\\u0433\\u043E \\u043A\\u0440\\u0438\\u0437\\u0438\\u0441\\u0430, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u0432\\u043E\\u0437\\u043D\\u0438\\u043A \\u043F\\u043E\\u0441\\u043B\\u0435 \\u0441\\u043C\\u0435\\u0440\\u0442\\u0438 \\u043A\\u043E\\u0440\\u043E\\u043B\\u044F \\u0410\\u043D\\u0433\\u043B\\u0438\\u0438 \\u0438 \\u0424\\u0440\\u0430\\u043D\\u0446\\u0438\\u0438 \\u0413\\u0435\\u043D\\u0440\\u0438\\u0445\\u0430 V \\u0432 1422 \\u0433\\u043E\\u0434\\u0443. \\u0423 \\u043A\\u043E\\u0440\\u043E\\u043B\\u044F \\u043D\\u0435 \\u0431\\u044B\\u043B\\u043E \\u0441\\u044B\\u043D\\u043E\\u0432\\u0435\\u0439, \\u0430 \\u0435\\u0433\\u043E \\u0435\\u0434\\u0438\\u043D\\u0441\\u0442\\u0432\\u0435\\u043D\\u043D\\u0430\\u044F \\u0434\\u043E\\u0447\\u044C \\u0432\\u044B\\u0448\\u043B\\u0430 \\u0437\\u0430\\u043C\\u0443\\u0436 \\u0437\\u0430 \\u041A\\u0430\\u0440\\u043B\\u0430, \\u0431\\u0443\\u0434\\u0443\\u0449\\u0435\\u0433\\u043E \\u043A\\u043E\\u0440\\u043E\\u043B\\u044F \\u0424\\u0440\\u0430\\u043D\\u0446\\u0438\\u0438. \\u042D\\u0442\\u043E \\u043F\\u0440\\u0438\\u0432\\u0435\\u043B\\u043E \\u043A \\u0441\\u043F\\u043E\\u0440\\u0443 \\u043E \\u043F\\u0440\\u0435\\u0441\\u0442\\u043E\\u043B\\u043E\\u043D\\u0430\\u0441\\u043B\\u0435\\u0434\\u0438\\u0438, \\u0432 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u043C \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043C\\u0435\\u0448\\u0430\\u043D\\u044B \\u0440\\u0430\\u0437\\u043B\\u0438\\u0447\\u043D\\u044B\\u0435 \\u043F\\u043E\\u043B\\u0438\\u0442\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0435 \\u0438 \\u0440\\u0435\\u043B\\u0438\\u0433\\u0438\\u043E\\u0437\\u043D\\u044B\\u0435 \\u0438\\u043D\\u0442\\u0435\\u0440\\u0435\\u0441\\u044B.\\n\\n2. **\\u0421\\u043E\\u043F\\u0435\\u0440\\u043D\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u043C\\u0435\\u0436\\u0434\\u0443 \\u0440\\u043E\\u0434\\u0430\\u043C\\u0438.** \\u0412\\u043E\\u0439\\u043D\\u044B \\u0431\\u044B\\u043B\\u0438 \\u0441\\u0432\\u044F\\u0437\\u0430\\u043D\\u044B \\u0441 \\u0431\\u043E\\u0440\\u044C\\u0431\\u043E\\u0439 \\u0437\\u0430 \\u0432\\u043B\\u0430\\u0441\\u0442\\u044C \\u043C\\u0435\\u0436\\u0434\\u0443 \\u0440\\u0430\\u0437\\u043B\\u0438\\u0447\\u043D\\u044B\\u043C\\u0438 \\u0440\\u043E\\u0434\\u0430\\u043C\\u0438 \\u0438 \\u043A\\u043B\\u0430\\u043D\\u0430\\u043C\\u0438, \\u0432\\u043A\\u043B\\u044E\\u0447\\u0430\\u044F \\u0419\\u043E\\u0440\\u043A\\u043E\\u0432 \\u0438 \\u041B\\u0430\\u043D\\u043A\\u0430\\u0441\\u0442\\u0435\\u0440\\u043E\\u0432, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u043F\\u0440\\u0435\\u0442\\u0435\\u043D\\u0434\\u043E\\u0432\\u0430\\u043B\\u0438 \\u043D\\u0430 \\u0442\\u0440\\u043E\\u043D. \\u042D\\u0442\\u0438 \\u0440\\u043E\\u0434\\u044B \\u0431\\u044B\\u043B\\u0438 \\u0441\\u0432\\u044F\\u0437\\u0430\\u043D\\u044B \\u0440\\u043E\\u0434\\u0441\\u0442\\u0432\\u0435\\u043D\\u043D\\u044B\\u043C\\u0438 \\u0441\\u0432\\u044F\\u0437\\u044F\\u043C\\u0438 \\u0441 \\u0434\\u0438\\u043D\\u0430\\u0441\\u0442\\u0438\\u0435\\u0439 \\u041B\\u0430\\u043D\\u043A\\u0430 \\u0438 \\u041F\\u043B\\u0430\\u043D\\u0442\\u0430\\u0433\\u0435\\u043D\\u0435\\u0442\\u043E\\u0432.\\n\\n3. **\\u0420\\u0435\\u043B\\u0438\\u0433\\u0438\\u043E\\u0437\\u043D\\u044B\\u0435 \\u0440\\u0430\\u0437\\u043D\\u043E\\u0433\\u043B\\u0430\\u0441\\u0438\\u044F.** \\u0412\\u043E\\u0439\\u043D\\u044B \\u0442\\u0430\\u043A\\u0436\\u0435 \\u0432\\u043A\\u043B\\u044E\\u0447\\u0430\\u043B\\u0438 \\u0440\\u0435\\u043B\\u0438\\u0433\\u0438\\u043E\\u0437\\u043D\\u044B\\u0435 \\u0440\\u0430\\u0437\\u043D\\u043E\\u0433\\u043B\\u0430\\u0441\\u0438\\u044F, \\u0442\\u0430\\u043A \\u043A\\u0430\\u043A \\u041B\\u0430\\u043D\\u043A\\u0430\\u0441\\u0442\\u0435\\u0440\\u044B \\u0431\\u044B\\u043B\\u0438 \\u0441\\u0442\\u043E\\u0440\\u043E\\u043D\\u043D\\u0438\\u043A\\u0430\\u043C\\u0438 \\u043A\\u0430\\u0442\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u043A\\u043E\\u0439 \\u0446\\u0435\\u0440\\u043A\\u0432\\u0438, \\u0430 \\u0419\\u043E\\u0440\\u043A\\u0438 \\u0431\\u044B\\u043B\\u0438 \\u0441\\u0432\\u044F\\u0437\\u0430\\u043D\\u044B \\u0441 \\u043E\\u043F\\u043F\\u043E\\u0437\\u0438\\u0446\\u0438\\u0435\\u0439 \\u043A \\u043D\\u0435\\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u043C \\u0430\\u0441\\u043F\\u0435\\u043A\\u0442\\u0430\\u043C \\u043A\\u0430\\u0442\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u043A\\u043E\\u0439 \\u0434\\u043E\\u043A\\u0442\\u0440\\u0438\\u043D\\u044B. \\u042D\\u0442\\u043E \\u0443\\u0441\\u0438\\u043B\\u0438\\u043B\\u043E \\u043D\\u0430\\u043F\\u0440\\u044F\\u0436\\u0435\\u043D\\u043D\\u043E\\u0441\\u0442\\u044C \\u0438 \\u043F\\u0440\\u0438\\u0432\\u0435\\u043B\\u043E \\u043A \\u043A\\u043E\\u043D\\u0444\\u043B\\u0438\\u043A\\u0442\\u0443.\\n\\n\\u0412\\u0430\\u0436\\u043D\\u043E \\u043E\\u0442\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C, \\u0447\\u0442\\u043E \\u044D\\u0442\\u043E \\u043B\\u0438\\u0448\\u044C \\u0432\\u043E\\u0437\\u043C\\u043E\\u0436\\u043D\\u044B\\u0435 \\u043F\\u0440\\u0438\\u0447\\u0438\\u043D\\u044B, \\u0438 \\u0442\\u043E\\u0447\\u043D\\u044B\\u0435 \\u043F\\u0440\\u0438\\u0447\\u0438\\u043D\\u044B \\u0432\\u043E\\u0439\\u043D \\u0410\\u043B\\u043E\\u0439 \\u0438 \\u0411\\u0435\\u043B\\u043E\\u0439 \\u0440\\u043E\\u0437\\u044B \\u0434\\u043E \\u0441\\u0438\\u0445 \\u043F\\u043E\\u0440 \\u044F\\u0432\\u043B\\u044F\\u044E\\u0442\\u0441\\u044F \\u043F\\u0440\\u0435\\u0434\\u043C\\u0435\\u0442\\u043E\\u043C \\u0434\\u0438\\u0441\\u043A\\u0443\\u0441\\u0441\\u0438\\u0439 \\u0441\\u0440\\u0435\\u0434\\u0438 \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u043A\\u043E\\u0432.\",\n                role: \"assistant\"\n            }\n        ]\n    }\n];\nconst $d3921e788426b86e$export$e1f907d5c8e9bfaf = {\n    // YandexGPT\n    \"yandexgpt\": \"yandexgpt\",\n    \"yandexgpt-lite\": \"yandexgpt\",\n    // GigaChat\n    \"GigaChat\": \"gigachat\",\n    \"GigaChat:latest\": \"gigachat\",\n    \"GigaChat-Plus\": \"gigachat\",\n    \"GigaChat-Pro\": \"gigachat\",\n    // ChatGPT\n    \"GPT-3.5\": \"chatgpt\",\n    \"GPT-4\": \"chatgpt\"\n};\nconst $d3921e788426b86e$export$d6b5295f355c2a70 = \"assistant-list__list-item_active\";\n\n\nconst $76323da5c2938e18$export$c2535c2eef2489fd = (modelId)=>{\n    const modelName = (0, $d3921e788426b86e$export$e1f907d5c8e9bfaf)[modelId];\n    const src = (0, (/*@__PURE__*/$parcel$interopDefault($4acad45e9fe5452d$exports)))[modelName];\n    return src;\n};\n\n\n\nconst $219c9e5acfa2b486$export$616aa94a0bd77e72 = ({ title: title, description: description, model: model })=>{\n    const element = document.createElement(\"header\");\n    element.classList.add(\"chat__header\");\n    element.innerHTML = `\n        <div class=\"chat__header-left\">\n            <img src=\"${(0, $76323da5c2938e18$export$c2535c2eef2489fd)(model.id)}\" />\n            <span class=\"chat__header-title\">${title}</span>\n            ${Boolean(description) ? `<span class=\"chat__header-description\">${description}</span>` : \"\"}\n        </div>\n        <div class=\"chat__header-right\">\n            <button class=\"button button__size_m button__view_clear button__width_auto button__align_center\">\n                <span class=\"icon icon__size_s\">\n                    <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <mask id=\"mask0_1_317\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"0\" y=\"0\" width=\"16\" height=\"16\">\n                            <rect width=\"16\" height=\"16\" fill=\"#D9D9D9\"/>\n                        </mask>\n                        <g mask=\"url(#mask0_1_317)\">\n                            <path d=\"M6.71538 13.4987C5.62478 13.2192 4.73291 12.6329 4.03975 11.7397C3.34658 10.8466 3 9.82222 3 8.66666C3 8.11196 3.0906 7.57521 3.2718 7.05641C3.453 6.53761 3.70941 6.05556 4.04103 5.61026C4.13333 5.48463 4.25876 5.41732 4.4173 5.40835C4.57584 5.39937 4.7158 5.45556 4.83717 5.57693C4.92948 5.66924 4.97734 5.77907 4.98075 5.90641C4.98417 6.03376 4.94528 6.15597 4.86408 6.27306C4.59401 6.61067 4.39358 6.98525 4.2628 7.39678C4.13203 7.80833 4.06665 8.23162 4.06665 8.66666C4.06665 9.55043 4.32392 10.3383 4.83845 11.0301C5.35298 11.722 6.02521 12.1906 6.85512 12.4359C6.97648 12.4786 7.08097 12.5573 7.16858 12.6718C7.25618 12.7863 7.29998 12.9043 7.29998 13.0256C7.29998 13.1923 7.24251 13.3235 7.12755 13.4192C7.01259 13.5149 6.87521 13.5414 6.71538 13.4987ZM9.28458 13.5115C9.12476 13.5542 8.98737 13.5288 8.87242 13.4352C8.75746 13.3416 8.69998 13.2115 8.69998 13.0449C8.69998 12.9192 8.74378 12.7991 8.83138 12.6846C8.91899 12.5701 9.02348 12.4893 9.14485 12.4423C9.97049 12.1799 10.6416 11.7049 11.1583 11.0173C11.675 10.3297 11.9333 9.54615 11.9333 8.66666C11.9333 7.56666 11.5555 6.63611 10.8 5.875C10.0444 5.11389 9.12221 4.73333 8.03332 4.73333H7.83073L8.31282 5.2154C8.42051 5.32309 8.47435 5.44574 8.47435 5.58335C8.47435 5.72095 8.42051 5.84359 8.31282 5.95128C8.19402 6.07008 8.06581 6.12948 7.9282 6.12948C7.7906 6.12948 7.66796 6.07008 7.56027 5.95128L6.24745 4.65513C6.17395 4.58163 6.1216 4.50749 6.0904 4.4327C6.0592 4.35791 6.0436 4.28035 6.0436 4.20001C6.0436 4.11967 6.0592 4.0421 6.0904 3.96731C6.1216 3.89254 6.17395 3.81839 6.24745 3.74488L7.56027 2.43206C7.66796 2.32438 7.7906 2.27053 7.9282 2.27053C8.06581 2.27053 8.19402 2.32438 8.31282 2.43206C8.42051 2.55086 8.47435 2.67907 8.47435 2.81668C8.47435 2.95428 8.42051 3.07693 8.31282 3.18461L7.83073 3.66668H8.03332C9.42818 3.66668 10.6047 4.1513 11.5628 5.12053C12.5209 6.08975 13 7.2718 13 8.66666C13 9.82222 12.6523 10.8444 11.957 11.7333C11.2617 12.6222 10.3709 13.2149 9.28458 13.5115Z\" fill=\"currentColor\"/>\n                        </g>\n                    </svg>                                    \n                </span>\n                <span class=\"button__text\">Clear chat</span>\n            </button>\n        </div>\n    `;\n    return element;\n};\nconst $219c9e5acfa2b486$export$344c62a49524fb80 = ({ role: role, text: text })=>{\n    const element = document.createElement(\"li\");\n    element.classList.add(\"chat__main-message\");\n    element.innerHTML = `\n        <span class=\"icon icon__size_l chat__main-role\">\n            <img src=\"${(0, (/*@__PURE__*/$parcel$interopDefault($9f15ba0f573fd662$exports)))[role]}\" />\n        </span>\n        <span class=\"text text__weight_light chat__main-text\">\n            ${(0, $d55025bea272cdc1$exports.marked).parse(text)}\n        </span>\n    `;\n    return element;\n};\n/**\n * Создаёт компонент список сообщений из чата\n * @param {Message[]} messages Список сообщений\n */ const $219c9e5acfa2b486$var$createMessagesElement = (messages)=>{\n    const element = document.createElement(\"ul\");\n    const children = messages.map((message)=>$219c9e5acfa2b486$export$344c62a49524fb80(message));\n    element.classList.add(\"chat__main-messages\");\n    element.append(...children);\n    return element;\n};\nconst $219c9e5acfa2b486$export$fb93690912c33dc2 = (messages)=>{\n    const element = document.createElement(\"div\");\n    const child = $219c9e5acfa2b486$var$createMessagesElement(messages);\n    element.classList.add(\"chat__main\");\n    element.appendChild(child);\n    return element;\n};\n/**\n * Создаёт компонент поля для ввода запроса\n */ const $219c9e5acfa2b486$var$createInputElement = ()=>{\n    const element = document.createElement(\"span\");\n    element.classList.add(\"input\", \"input__size_l\", \"chat__footer-input\");\n    element.innerHTML = `\n        <input placeholder=\"Let the magic begin. Ask a question\" />\n        <button\n            class=\"button button__size_l button__view_clear button__width_auto button__align_center chat__footer-button\"\n            aria-label=\"Send\"\n        >\n            <span class=\"icon icon__size_m\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                    <mask id=\"mask0_1_451\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"0\" y=\"0\" width=\"20\" height=\"20\">\n                        <rect width=\"20\" height=\"20\" fill=\"#D9D9D9\"/>\n                    </mask>\n                    <g mask=\"url(#mask0_1_451)\">\n                        <path d=\"M2.5 16.6667V3.33334L18.3333 10L2.5 16.6667ZM4.16667 14.1667L14.0417 10L4.16667 5.83334V8.75001L9.16667 10L4.16667 11.25V14.1667Z\" fill=\"currentColor\"/>\n                    </g>\n                </svg>                                \n            </span>\n        </button>\n    `;\n    return element;\n};\nconst $219c9e5acfa2b486$export$d167602a1ab5333e = ()=>{\n    const element = document.createElement(\"footer\");\n    const childElement = $219c9e5acfa2b486$var$createInputElement();\n    element.classList.add(\"chat__footer\");\n    element.appendChild(childElement);\n    return element;\n};\n\n\nclass $aad038f1bb9105f1$export$404990ef005f452b {\n    /**\n     * Конструктор представления чата с ассистентом\n     * @param {Assistant} assistant Объект ассистента\n     */ /**\n     * Конструктор представления чата с ассистентом\n     * @param {Object} props\n     * @param {Assistant} props.assistant \n     * @param {(text: string) => Promise<void>} props.onSend\n     */ constructor(props){\n        const { assistant: assistant, onSend: onSend } = props;\n        this._assistant = assistant;\n        this._onSend = onSend;\n    }\n    _getMessages() {\n        const { messages: messages } = this._assistant;\n        return messages;\n    }\n    /**\n     * Рендерит шапку чата с информацией об ассистенте\n     */ renderHeader() {\n        const previousHeader = document.getElementsByClassName(\"chat__header\")[0];\n        const chat = previousHeader.parentElement;\n        const nextHeader = (0, $219c9e5acfa2b486$export$616aa94a0bd77e72)(this._assistant);\n        chat?.replaceChild(nextHeader, previousHeader);\n    }\n    /**\n     * Рендерит основной контент чата\n     */ renderMain() {\n        const previousMain = document.getElementsByClassName(\"chat__main\")[0];\n        const chat = previousMain.parentElement;\n        const messages = this._getMessages();\n        const nextMain = (0, $219c9e5acfa2b486$export$fb93690912c33dc2)(messages);\n        chat?.replaceChild(nextMain, previousMain);\n    }\n    /**\n     * Рендерит новое сообщение в чате\n     * @param {Message} message \n     */ renderNewMessage(message) {\n        const list = document.getElementsByClassName(\"chat__main-messages\")[0];\n        const element = (0, $219c9e5acfa2b486$export$344c62a49524fb80)(message);\n        list.appendChild(element);\n    }\n    /**\n     * Очищает содержимое поля для ввода текста (инпута)\n     * @param {HTMLInputElement} input Элемент поля для ввода текста (инпут)\n     */ _clearInput(input) {\n        input.value = \"\";\n    }\n    /**\n     * Обработчик отправки сообщения в чат\n     */ send(event) {\n        const input = document.querySelector(\".chat__footer-input > input\");\n        if (event.type === \"keydown\" && event.code !== \"Enter\") return;\n        const text = input?.value;\n        if (!text) return;\n        this._onSend(text);\n        this._clearInput(input);\n    }\n    /**\n     * Рендерит футер (подвал) чата с ассистентом\n     */ renderFooter() {\n        const previousFooter = document.getElementsByClassName(\"chat__footer\")[0];\n        const chat = previousFooter.parentElement;\n        const nextFooter = (0, $219c9e5acfa2b486$export$d167602a1ab5333e)();\n        const handleSend = this.send.bind(this);\n        const input = nextFooter.querySelector(\".chat__footer-input\");\n        const button = nextFooter.querySelector(\".chat__footer-button\");\n        input?.addEventListener(\"keydown\", handleSend);\n        button?.addEventListener(\"click\", handleSend);\n        chat?.replaceChild(nextFooter, previousFooter);\n    }\n    /**\n     * Рендерит чат с ассистентом\n     */ render() {\n        this.renderHeader();\n        this.renderMain();\n        this.renderFooter();\n    }\n}\n\n\n\n\n\n\nconst $aeb01e3ae829b153$export$1586efe9e3013a67 = ({ id: id, title: title, description: description, model: model })=>{\n    const element = document.createElement(\"li\");\n    element.setAttribute(\"assistant-id\", id);\n    element.classList.add(\"assistant-list__list-item\");\n    element.innerHTML = `\n        <button>\n            <span class=\"icon icon__size_s\">\n                <img src=\"${(0, $76323da5c2938e18$export$c2535c2eef2489fd)(model.id)}\" />\n            </span>\n            <div class=\"assistant-list__list-item-content\">\n                <span class=\"assistant-list__list-item-title\">${title}</span>\n                ${Boolean(description) ? `<span class=\"assistant-list__list-item-description\">${description}</span>` : \"\"}\n            </div>\n        </button>\n    `;\n    return element;\n};\n\n\nclass $b4de022fb8244c8b$export$5fe8222595b01ed2 {\n    /**\n     * Конструктор представления бокового меню\n     * @param {Object} props\n     * @param {Assistant[]} props.assistants \n     * @param {(id: string) => Promise<void>} props.onClick\n     */ constructor(props){\n        const { assistants: assistants, onClick: onClick } = props;\n        this._assistants = assistants;\n        this._onClick = onClick;\n    }\n    /**\n     * Возвращает элемент активного ассистента\n     * @returns {Element | null}\n     */ _getActiveAssistant() {\n        const assistant = document.getElementsByClassName((0, $d3921e788426b86e$export$d6b5295f355c2a70))[0];\n        return assistant || null;\n    }\n    /**\n     * Возвращает идентификатор активного ассистента\n     * @returns {String}\n     */ getActiveAssistantId() {\n        const assistant = this._getActiveAssistant();\n        if (!assistant) return null;\n        const id = assistant.getAttribute(\"assistant-id\");\n        return id;\n    }\n    /**\n     * Переключает ассистента из бокового меню\n     * @param {String} id Идентификатор ассистента \n     */ _onToggle(id) {\n        const selectedAssistant = this._getActiveAssistant();\n        const currentAssistant = document.querySelector(`[assistant-id=\"${id}\"]`);\n        selectedAssistant?.classList.remove((0, $d3921e788426b86e$export$d6b5295f355c2a70));\n        currentAssistant?.classList.toggle((0, $d3921e788426b86e$export$d6b5295f355c2a70));\n    }\n    /**\n     * Обработчик нажатия на элемент бокового меню\n     */ async click({ currentTarget: currentTarget }) {\n        const id = currentTarget.getAttribute(\"assistant-id\");\n        const activeId = this.getActiveAssistantId();\n        if (id === activeId) return;\n        await this._onClick(id);\n        this._onToggle(id);\n    }\n    /**\n     * Рендерит список ассистентов в боковом меню\n     */ render() {\n        const parentElement = document.getElementsByClassName(\"assistant-list__list\")[0];\n        const handleClick = this.click.bind(this);\n        for (const assistant of this._assistants){\n            const element = (0, $aeb01e3ae829b153$export$1586efe9e3013a67)(assistant);\n            element.addEventListener(\"click\", handleClick);\n            parentElement.appendChild(element);\n        }\n    }\n}\n\n\n\n\nconst $a33f52700f6fa316$var$API_URL = \"http://localhost:5001/api\";\nconst $a33f52700f6fa316$var$api = async (path = \"\", options)=>{\n    const url = `${$a33f52700f6fa316$var$API_URL}/${path}`;\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) throw data;\n    return data;\n};\nconst $a33f52700f6fa316$export$40ce17753a1d1785 = ()=>$a33f52700f6fa316$var$api(\"chats\");\nconst $a33f52700f6fa316$export$426c95e07c389742 = (id)=>$a33f52700f6fa316$var$api(`chats/${id}`);\nconst $a33f52700f6fa316$export$8538b1a2f7ba7003 = async (data)=>{\n    const assistant = await $a33f52700f6fa316$var$api(\"chats\", {\n        method: \"POST\",\n        body: JSON.stringify(data),\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    return assistant;\n};\nconst $a33f52700f6fa316$export$66d0e4a367dc1d5b = (id)=>$a33f52700f6fa316$var$api(`chats/${id}`, {\n        method: \"DELETE\"\n    });\nconst $a33f52700f6fa316$export$62651879628e0c4c = async (id, userText)=>{\n    const { text: text } = await $a33f52700f6fa316$var$api(`chats/${id}/messages`, {\n        method: \"POST\",\n        body: JSON.stringify({\n            text: userText\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    return text;\n};\nconst $a33f52700f6fa316$export$1effe14d114525fa = (id)=>$a33f52700f6fa316$var$api(`chats/${id}/messages`, {\n        method: \"DELETE\"\n    });\n\n\n\n\nclass $000500fde1ff7210$export$7ca9b0e795b607f1 {\n    /**\n     * Функция-конструктор класса AssistantModel\n     * @param {Assistant[]} [assistants] Список объектов ассистентов\n     */ constructor(assistants = []){\n        const initialAssistants = assistants.map((assistant)=>this._createInitialAssistant(assistant));\n        this._assistants = initialAssistants;\n    }\n    /**\n     * Создаёт объект модели по умолчанию, насыщенный пользовательскими настройками\n     * @param {Model} model Пользовательские настройки модели\n     * @returns {Model} Насыщенный объект модели\n     */ _createInitialModel(model) {\n        const initialModel = {\n            stream: false,\n            temperature: 0.6,\n            maxTokens: 2000\n        };\n        return {\n            ...initialModel,\n            ...model\n        };\n    }\n    /**\n     * Создаёт объект ассистента по умолчанию, насыщенный пользовательскими настройками\n     * @param {Assistant} assistant Пользовательские настройки ассистента\n     * @returns {Assistant} Насыщенный объект ассистента\n     */ _createInitialAssistant(assistant) {\n        const initialAssistant = {\n            instruction: \"\"\n        };\n        return {\n            ...initialAssistant,\n            ...assistant,\n            model: this._createInitialModel(assistant.model)\n        };\n    }\n    getAssistants() {\n        return this._assistants;\n    }\n    /**\n     * Возвращает ассистента из списка ассистентов по его идентификатору\n     * @param {*} id Идентификатор ассистента\n     * @returns {Assistant | null} Объект ассистента (или `null`, если ассистента с таким id нет в списке)\n     */ getAssistantById(id) {\n        return this._assistants.find((assistant)=>assistant.id === id) || null;\n    }\n    /**\n     * Обновляет объект ассистента в списке или добавляет, если его ранее там не было\n     * @param {Assistant} newAssistant Новый объект ассистента\n     */ updateAssistant(newAssistant) {\n        const { id: id } = newAssistant;\n        const oldAssistant = this.getAssistantById(id);\n        if (!oldAssistant) {\n            this._assistants.push(newAssistant);\n            return;\n        }\n        Object.assign(oldAssistant, newAssistant);\n    }\n    /**\n     * Возвращает данные ассистента для отображения\n     * @param {String} assistantId Идентификатор ассистента\n     */ getDisplayedData(id) {\n        const assistant = this.getAssistantById(id);\n        if (!assistant) throw new Error(\"NOT_FOUND\");\n        const { title: title, description: description, model: model } = assistant;\n        return {\n            id: id,\n            title: title,\n            description: description,\n            icon: (0, $76323da5c2938e18$export$c2535c2eef2489fd)(model.id)\n        };\n    }\n    /**\n     * Возвращает сообщения из чата с ассистентом\n     * @param {String} id Идентификатор ассистента\n     * @returns {Message[]} Сообщения\n     */ getMessages(id) {\n        const assistant = this.getAssistantById(id);\n        if (!assistant) throw new Error(\"ASSISTANT_NOT_FOUND\");\n        return assistant.messages;\n    }\n    /**\n     * Добавляет сообщение в чат с ассистентом\n     * @param {Message} message Сообщение\n     * @param {String} id Идентификатор ассистента\n     */ addMessage(message, id) {\n        const assistant = this.getAssistantById(id);\n        if (!assistant) throw new Error(\"ASSISTANT_NOT_FOUND\");\n        assistant.messages.push(message);\n    }\n}\n\n\nclass $1e3f496bba0e4234$export$bd63dc5a00fdc201 {\n    /**\n     * Конструктор класса контроллера приложения\n     * @param {Assistant[]} [assistants] Список объектов ассистентов\n     */ constructor(assistants = []){\n        this._model = new (0, $000500fde1ff7210$export$7ca9b0e795b607f1)(assistants);\n        this._menuView = new (0, $b4de022fb8244c8b$export$5fe8222595b01ed2)({\n            assistants: assistants,\n            onClick: this._onAssistantChange.bind(this)\n        });\n    }\n    /**\n     * Обновляет представление чата\n     * @param {Assistant} assistant Объект ассистента\n     */ _updateChatView(assistant) {\n        this._chatView = new (0, $aad038f1bb9105f1$export$404990ef005f452b)({\n            assistant: assistant,\n            onSend: this._onMessageSend.bind(this)\n        });\n        this._chatView.render();\n    }\n    /**\n     * Обработчик переключения ассистента в боковом меню\n     * @param {String} id Идентификатор ассистента\n     */ async _onAssistantChange(id) {\n        const cachedAssistant = this._model.getAssistantById(id);\n        const hasMessages = Boolean(cachedAssistant.messages);\n        if (!hasMessages) {\n            const serverAssistant = await $a33f52700f6fa316$export$426c95e07c389742(id);\n            this._model.updateAssistant(serverAssistant);\n            this._updateChatView(serverAssistant);\n            return;\n        }\n        this._updateChatView(cachedAssistant);\n    }\n    /**\n     * Обработчик добавления нового сообщения\n     * @param {Message} message Объект сообщения\n     * @param {String} id Идентификатор ассистента\n     */ _onMessageAdd(message, id) {\n        this._model.addMessage(message, id);\n        this._chatView.renderNewMessage(message);\n    }\n    /**\n     * Обработчик отправки сообщения в чате\n     * @param {String} userText Текст пользовательского сообщения \n     */ async _onMessageSend(userText) {\n        const id = this._menuView.getActiveAssistantId();\n        const userMessage = {\n            text: userText,\n            role: \"user\"\n        };\n        this._onMessageAdd(userMessage, id);\n        const assistantText = await $a33f52700f6fa316$export$62651879628e0c4c(id, userText);\n        const assistantMessage = {\n            text: assistantText,\n            role: \"assistant\"\n        };\n        this._onMessageAdd(assistantMessage, id);\n    }\n    init() {\n        this._menuView.render();\n    }\n}\n\n\n\nconst $cba3eb2abed8e80a$var$start = async ()=>{\n    const assistants = await (0, $a33f52700f6fa316$export$40ce17753a1d1785)();\n    const app = new (0, $1e3f496bba0e4234$export$bd63dc5a00fdc201)(assistants);\n    app.init();\n};\ndocument.addEventListener(\"DOMContentLoaded\", $cba3eb2abed8e80a$var$start);\n\n\n//# sourceMappingURL=index.19cd5666.js.map\n","import { AppController } from './app/controller';\nimport { getAssistants } from './shared/api';\n\nconst start = async () => {\n    const assistants = await getAssistants();\n\n    const app = new AppController(assistants);\n\n    app.init();\n};\n\ndocument.addEventListener('DOMContentLoaded', start);\n","import { ChatView } from '../features/chat/view';\nimport { MenuView } from '../features/menu/view';\nimport { Assistant, Message } from '../shared/types';\nimport * as api from '../shared/api';\n\nimport { AssistantModel } from './model';\n\nexport class AppController {\n    /**\n     * Конструктор класса контроллера приложения\n     * @param {Assistant[]} [assistants] Список объектов ассистентов\n     */\n    constructor(assistants = []) {\n        this._model = new AssistantModel(assistants);\n\n        this._menuView = new MenuView({\n            assistants,\n            onClick: this._onAssistantChange.bind(this)\n        });\n    }\n\n    /**\n     * Обновляет представление чата\n     * @param {Assistant} assistant Объект ассистента\n     */\n    _updateChatView(assistant) {\n        this._chatView = new ChatView({\n            assistant,\n            onSend: this._onMessageSend.bind(this)\n        });\n\n        this._chatView.render();\n    }\n\n    /**\n     * Обработчик переключения ассистента в боковом меню\n     * @param {String} id Идентификатор ассистента\n     */\n    async _onAssistantChange(id) {\n        const cachedAssistant = this._model.getAssistantById(id);\n        const hasMessages = Boolean(cachedAssistant.messages);\n\n        if (!hasMessages) {\n            const serverAssistant = await api.getAssistant(id);\n\n            this._model.updateAssistant(serverAssistant);\n            this._updateChatView(serverAssistant);\n\n            return;\n        }\n\n        this._updateChatView(cachedAssistant);\n    }\n\n    /**\n     * Обработчик добавления нового сообщения\n     * @param {Message} message Объект сообщения\n     * @param {String} id Идентификатор ассистента\n     */\n    _onMessageAdd(message, id) {\n        this._model.addMessage(message, id);\n        this._chatView.renderNewMessage(message);\n    }\n\n    /**\n     * Обработчик отправки сообщения в чате\n     * @param {String} userText Текст пользовательского сообщения \n     */\n    async _onMessageSend(userText) {\n        const id = this._menuView.getActiveAssistantId();\n\n        const userMessage = {\n            text: userText,\n            role: 'user'\n        };\n\n        this._onMessageAdd(userMessage, id);\n\n        const assistantText = await api.createMessage(id, userText);\n\n        const assistantMessage = {\n            text: assistantText,\n            role: 'assistant'\n        };\n\n        this._onMessageAdd(assistantMessage, id);\n    }\n\n    init() {\n        this._menuView.render();\n    }\n}\n","import { Assistant, Message } from '../../shared/types';\nimport {\n    createHeaderElement,\n    createMainElement,\n    createMessageElement,\n    createFooterElement\n} from './templates';\n\nexport class ChatView {\n    /**\n     * Конструктор представления чата с ассистентом\n     * @param {Assistant} assistant Объект ассистента\n     */\n    /**\n     * Конструктор представления чата с ассистентом\n     * @param {Object} props\n     * @param {Assistant} props.assistant \n     * @param {(text: string) => Promise<void>} props.onSend\n     */\n    constructor(props) {\n        const { assistant, onSend } = props;\n\n        this._assistant = assistant;\n        this._onSend = onSend;\n    }\n\n    _getMessages() {\n        const { messages } = this._assistant;\n\n        return messages;\n    }\n\n    /**\n     * Рендерит шапку чата с информацией об ассистенте\n     */\n    renderHeader() {\n        const previousHeader = document.getElementsByClassName('chat__header')[0];\n        const chat = previousHeader.parentElement;\n        \n        const nextHeader = createHeaderElement(this._assistant);\n\n        chat?.replaceChild(nextHeader, previousHeader);\n    }\n\n    /**\n     * Рендерит основной контент чата\n     */\n    renderMain() {\n        const previousMain = document.getElementsByClassName('chat__main')[0];\n        const chat = previousMain.parentElement;\n        \n        const messages = this._getMessages();\n        const nextMain = createMainElement(messages);\n\n        chat?.replaceChild(nextMain, previousMain);\n    }\n\n    /**\n     * Рендерит новое сообщение в чате\n     * @param {Message} message \n     */\n    renderNewMessage(message) {\n        const list = document.getElementsByClassName('chat__main-messages')[0];\n        const element = createMessageElement(message);\n\n        list.appendChild(element);\n    }\n\n    /**\n     * Очищает содержимое поля для ввода текста (инпута)\n     * @param {HTMLInputElement} input Элемент поля для ввода текста (инпут)\n     */\n    _clearInput(input) {\n        input.value = '';\n    }\n\n    /**\n     * Обработчик отправки сообщения в чат\n     */\n    send(event) {\n        const input = document.querySelector('.chat__footer-input > input');\n\n        if (event.type === 'keydown' && event.code !== 'Enter') {\n            return;\n        }\n\n        const text = input?.value;\n\n        if (!text) {\n            return;\n        }\n\n        this._onSend(text);\n        this._clearInput(input);\n    }\n\n    /**\n     * Рендерит футер (подвал) чата с ассистентом\n     */\n    renderFooter() {\n        const previousFooter = document.getElementsByClassName('chat__footer')[0];\n        const chat = previousFooter.parentElement;\n\n        const nextFooter = createFooterElement();\n        const handleSend = this.send.bind(this);\n\n        const input = nextFooter.querySelector('.chat__footer-input');\n        const button = nextFooter.querySelector('.chat__footer-button');\n\n        input?.addEventListener('keydown', handleSend);\n        button?.addEventListener('click', handleSend);\n\n        chat?.replaceChild(nextFooter, previousFooter);\n    }\n\n    /**\n     * Рендерит чат с ассистентом\n     */\n    render() {\n        this.renderHeader();\n        this.renderMain();\n        this.renderFooter();\n    }\n}\n","/**\n * @typedef {Object} Model - LLM\n * @property {Number} id - Идентификатор LLM (например, \"yandexgpt\")\n * @property {Boolean} [stream=false] - Флаг потоковой передачи ответа LLM\n * @property {Number} [temperature=0.6] - Коэффициент рандомности ответа LLM\n * @property {Number} [maxTokens=2000] - Максимальное количество токенов в ответе LLM\n */\n\n/**\n * @typedef {Object} Message - Сообщение\n * @property {\"user\"|\"assistant\"|\"system\"} role - Роль отправителя сообщения\n * @property {String} text - Текст сообщения\n */\n\n/**\n * @typedef {Object} Assistant - Ассистент\n * @property {String} id Идентификатор ассистента\n * @property {String} title Название ассистента\n * @property {String} [description] Описание ассистента (необязательное)\n * @property {String} [instruction] Промпт-инструкция ассистента\n * @property {Model} model Объект LLM, используемой ассистентом\n * @property {Message[]} messages Сообщения из чата с ассистентом\n */\n\nexport const Types = {};\n","import { marked } from 'marked';\n\nimport icons from '../../../assets/*.svg';\n\nimport { getModelIcon } from '../../shared/utils';\nimport { Assistant, Message } from '../../shared/types';\n\n/**\n * Создаёт компонент шапки чата с ассистентом\n * @param {Assistant} assistant Объект ассистента\n */\nexport const createHeaderElement = ({ title, description, model }) => {\n    const element = document.createElement('header');\n\n    element.classList.add('chat__header');\n\n    element.innerHTML = `\n        <div class=\"chat__header-left\">\n            <img src=\"${getModelIcon(model.id)}\" />\n            <span class=\"chat__header-title\">${title}</span>\n            ${Boolean(description) ? `<span class=\"chat__header-description\">${description}</span>` : ''}\n        </div>\n        <div class=\"chat__header-right\">\n            <button class=\"button button__size_m button__view_clear button__width_auto button__align_center\">\n                <span class=\"icon icon__size_s\">\n                    <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <mask id=\"mask0_1_317\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"0\" y=\"0\" width=\"16\" height=\"16\">\n                            <rect width=\"16\" height=\"16\" fill=\"#D9D9D9\"/>\n                        </mask>\n                        <g mask=\"url(#mask0_1_317)\">\n                            <path d=\"M6.71538 13.4987C5.62478 13.2192 4.73291 12.6329 4.03975 11.7397C3.34658 10.8466 3 9.82222 3 8.66666C3 8.11196 3.0906 7.57521 3.2718 7.05641C3.453 6.53761 3.70941 6.05556 4.04103 5.61026C4.13333 5.48463 4.25876 5.41732 4.4173 5.40835C4.57584 5.39937 4.7158 5.45556 4.83717 5.57693C4.92948 5.66924 4.97734 5.77907 4.98075 5.90641C4.98417 6.03376 4.94528 6.15597 4.86408 6.27306C4.59401 6.61067 4.39358 6.98525 4.2628 7.39678C4.13203 7.80833 4.06665 8.23162 4.06665 8.66666C4.06665 9.55043 4.32392 10.3383 4.83845 11.0301C5.35298 11.722 6.02521 12.1906 6.85512 12.4359C6.97648 12.4786 7.08097 12.5573 7.16858 12.6718C7.25618 12.7863 7.29998 12.9043 7.29998 13.0256C7.29998 13.1923 7.24251 13.3235 7.12755 13.4192C7.01259 13.5149 6.87521 13.5414 6.71538 13.4987ZM9.28458 13.5115C9.12476 13.5542 8.98737 13.5288 8.87242 13.4352C8.75746 13.3416 8.69998 13.2115 8.69998 13.0449C8.69998 12.9192 8.74378 12.7991 8.83138 12.6846C8.91899 12.5701 9.02348 12.4893 9.14485 12.4423C9.97049 12.1799 10.6416 11.7049 11.1583 11.0173C11.675 10.3297 11.9333 9.54615 11.9333 8.66666C11.9333 7.56666 11.5555 6.63611 10.8 5.875C10.0444 5.11389 9.12221 4.73333 8.03332 4.73333H7.83073L8.31282 5.2154C8.42051 5.32309 8.47435 5.44574 8.47435 5.58335C8.47435 5.72095 8.42051 5.84359 8.31282 5.95128C8.19402 6.07008 8.06581 6.12948 7.9282 6.12948C7.7906 6.12948 7.66796 6.07008 7.56027 5.95128L6.24745 4.65513C6.17395 4.58163 6.1216 4.50749 6.0904 4.4327C6.0592 4.35791 6.0436 4.28035 6.0436 4.20001C6.0436 4.11967 6.0592 4.0421 6.0904 3.96731C6.1216 3.89254 6.17395 3.81839 6.24745 3.74488L7.56027 2.43206C7.66796 2.32438 7.7906 2.27053 7.9282 2.27053C8.06581 2.27053 8.19402 2.32438 8.31282 2.43206C8.42051 2.55086 8.47435 2.67907 8.47435 2.81668C8.47435 2.95428 8.42051 3.07693 8.31282 3.18461L7.83073 3.66668H8.03332C9.42818 3.66668 10.6047 4.1513 11.5628 5.12053C12.5209 6.08975 13 7.2718 13 8.66666C13 9.82222 12.6523 10.8444 11.957 11.7333C11.2617 12.6222 10.3709 13.2149 9.28458 13.5115Z\" fill=\"currentColor\"/>\n                        </g>\n                    </svg>                                    \n                </span>\n                <span class=\"button__text\">Clear chat</span>\n            </button>\n        </div>\n    `;\n\n    return element;\n};\n\n/**\n * Создаёт компонент сообщения из чата\n * @param {Message} message Сообщение\n */\nexport const createMessageElement = ({ role, text }) => {\n    const element = document.createElement('li');\n\n    element.classList.add('chat__main-message');\n\n    element.innerHTML = `\n        <span class=\"icon icon__size_l chat__main-role\">\n            <img src=\"${icons[role]}\" />\n        </span>\n        <span class=\"text text__weight_light chat__main-text\">\n            ${marked.parse(text)}\n        </span>\n    `;\n\n    return element;\n};\n\n/**\n * Создаёт компонент список сообщений из чата\n * @param {Message[]} messages Список сообщений\n */\nconst createMessagesElement = (messages) => {\n    const element = document.createElement('ul');\n    const children = messages.map((message) => createMessageElement(message));\n    \n    element.classList.add('chat__main-messages');\n    element.append(...children);\n\n    return element;\n};\n\n/**\n * Создаёт компонент с основным контентом чата\n * @param {Message[]} messages Список сообщений\n */\nexport const createMainElement = (messages) => {\n    const element = document.createElement('div');\n    const child = createMessagesElement(messages);\n\n    element.classList.add('chat__main');\n    element.appendChild(child);\n\n    return element;\n};\n\n/**\n * Создаёт компонент поля для ввода запроса\n */\nconst createInputElement = () => {\n    const element = document.createElement('span');\n\n    element.classList.add('input', 'input__size_l', 'chat__footer-input');\n\n    element.innerHTML = `\n        <input placeholder=\"Let the magic begin. Ask a question\" />\n        <button\n            class=\"button button__size_l button__view_clear button__width_auto button__align_center chat__footer-button\"\n            aria-label=\"Send\"\n        >\n            <span class=\"icon icon__size_m\">\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                    <mask id=\"mask0_1_451\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"0\" y=\"0\" width=\"20\" height=\"20\">\n                        <rect width=\"20\" height=\"20\" fill=\"#D9D9D9\"/>\n                    </mask>\n                    <g mask=\"url(#mask0_1_451)\">\n                        <path d=\"M2.5 16.6667V3.33334L18.3333 10L2.5 16.6667ZM4.16667 14.1667L14.0417 10L4.16667 5.83334V8.75001L9.16667 10L4.16667 11.25V14.1667Z\" fill=\"currentColor\"/>\n                    </g>\n                </svg>                                \n            </span>\n        </button>\n    `;\n\n    return element;\n};\n\n/**\n * Создаёт компонент футера (подвала) чата с ассистентом\n */\nexport const createFooterElement = () => {\n    const element = document.createElement('footer');\n    const childElement = createInputElement();\n\n    element.classList.add('chat__footer');\n    element.appendChild(childElement);\n\n    return element;\n};\n","/**\n * marked v12.0.1 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));\n})(this, (function (exports) { 'use strict';\n\n    /**\n     * Gets the original marked default options.\n     */\n    function _getDefaults() {\n        return {\n            async: false,\n            breaks: false,\n            extensions: null,\n            gfm: true,\n            hooks: null,\n            pedantic: false,\n            renderer: null,\n            silent: false,\n            tokenizer: null,\n            walkTokens: null\n        };\n    }\n    exports.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n        exports.defaults = newDefaults;\n    }\n\n    /**\n     * Helpers\n     */\n    const escapeTest = /[&<>\"']/;\n    const escapeReplace = new RegExp(escapeTest.source, 'g');\n    const escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\n    const escapeReplacements = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;'\n    };\n    const getEscapeReplacement = (ch) => escapeReplacements[ch];\n    function escape$1(html, encode) {\n        if (encode) {\n            if (escapeTest.test(html)) {\n                return html.replace(escapeReplace, getEscapeReplacement);\n            }\n        }\n        else {\n            if (escapeTestNoEncode.test(html)) {\n                return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n            }\n        }\n        return html;\n    }\n    const unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n    function unescape(html) {\n        // explicitly match decimal, hex, and named HTML entities\n        return html.replace(unescapeTest, (_, n) => {\n            n = n.toLowerCase();\n            if (n === 'colon')\n                return ':';\n            if (n.charAt(0) === '#') {\n                return n.charAt(1) === 'x'\n                    ? String.fromCharCode(parseInt(n.substring(2), 16))\n                    : String.fromCharCode(+n.substring(1));\n            }\n            return '';\n        });\n    }\n    const caret = /(^|[^\\[])\\^/g;\n    function edit(regex, opt) {\n        let source = typeof regex === 'string' ? regex : regex.source;\n        opt = opt || '';\n        const obj = {\n            replace: (name, val) => {\n                let valSource = typeof val === 'string' ? val : val.source;\n                valSource = valSource.replace(caret, '$1');\n                source = source.replace(name, valSource);\n                return obj;\n            },\n            getRegex: () => {\n                return new RegExp(source, opt);\n            }\n        };\n        return obj;\n    }\n    function cleanUrl(href) {\n        try {\n            href = encodeURI(href).replace(/%25/g, '%');\n        }\n        catch (e) {\n            return null;\n        }\n        return href;\n    }\n    const noopTest = { exec: () => null };\n    function splitCells(tableRow, count) {\n        // ensure that every cell-delimiting pipe has a space\n        // before it to distinguish it from an escaped pipe\n        const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n            let escaped = false;\n            let curr = offset;\n            while (--curr >= 0 && str[curr] === '\\\\')\n                escaped = !escaped;\n            if (escaped) {\n                // odd number of slashes means | is escaped\n                // so we leave it alone\n                return '|';\n            }\n            else {\n                // add space before unescaped |\n                return ' |';\n            }\n        }), cells = row.split(/ \\|/);\n        let i = 0;\n        // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n        if (!cells[0].trim()) {\n            cells.shift();\n        }\n        if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n            cells.pop();\n        }\n        if (count) {\n            if (cells.length > count) {\n                cells.splice(count);\n            }\n            else {\n                while (cells.length < count)\n                    cells.push('');\n            }\n        }\n        for (; i < cells.length; i++) {\n            // leading or trailing whitespace is ignored per the gfm spec\n            cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n        }\n        return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */\n    function rtrim(str, c, invert) {\n        const l = str.length;\n        if (l === 0) {\n            return '';\n        }\n        // Length of suffix matching the invert condition.\n        let suffLen = 0;\n        // Step left until we fail to match the invert condition.\n        while (suffLen < l) {\n            const currChar = str.charAt(l - suffLen - 1);\n            if (currChar === c && !invert) {\n                suffLen++;\n            }\n            else if (currChar !== c && invert) {\n                suffLen++;\n            }\n            else {\n                break;\n            }\n        }\n        return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n        if (str.indexOf(b[1]) === -1) {\n            return -1;\n        }\n        let level = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (str[i] === '\\\\') {\n                i++;\n            }\n            else if (str[i] === b[0]) {\n                level++;\n            }\n            else if (str[i] === b[1]) {\n                level--;\n                if (level < 0) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    function outputLink(cap, link, raw, lexer) {\n        const href = link.href;\n        const title = link.title ? escape$1(link.title) : null;\n        const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n        if (cap[0].charAt(0) !== '!') {\n            lexer.state.inLink = true;\n            const token = {\n                type: 'link',\n                raw,\n                href,\n                title,\n                text,\n                tokens: lexer.inlineTokens(text)\n            };\n            lexer.state.inLink = false;\n            return token;\n        }\n        return {\n            type: 'image',\n            raw,\n            href,\n            title,\n            text: escape$1(text)\n        };\n    }\n    function indentCodeCompensation(raw, text) {\n        const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n        if (matchIndentToCode === null) {\n            return text;\n        }\n        const indentToCode = matchIndentToCode[1];\n        return text\n            .split('\\n')\n            .map(node => {\n            const matchIndentInNode = node.match(/^\\s+/);\n            if (matchIndentInNode === null) {\n                return node;\n            }\n            const [indentInNode] = matchIndentInNode;\n            if (indentInNode.length >= indentToCode.length) {\n                return node.slice(indentToCode.length);\n            }\n            return node;\n        })\n            .join('\\n');\n    }\n    /**\n     * Tokenizer\n     */\n    class _Tokenizer {\n        options;\n        rules; // set by the lexer\n        lexer; // set by the lexer\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        space(src) {\n            const cap = this.rules.block.newline.exec(src);\n            if (cap && cap[0].length > 0) {\n                return {\n                    type: 'space',\n                    raw: cap[0]\n                };\n            }\n        }\n        code(src) {\n            const cap = this.rules.block.code.exec(src);\n            if (cap) {\n                const text = cap[0].replace(/^ {1,4}/gm, '');\n                return {\n                    type: 'code',\n                    raw: cap[0],\n                    codeBlockStyle: 'indented',\n                    text: !this.options.pedantic\n                        ? rtrim(text, '\\n')\n                        : text\n                };\n            }\n        }\n        fences(src) {\n            const cap = this.rules.block.fences.exec(src);\n            if (cap) {\n                const raw = cap[0];\n                const text = indentCodeCompensation(raw, cap[3] || '');\n                return {\n                    type: 'code',\n                    raw,\n                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                    text\n                };\n            }\n        }\n        heading(src) {\n            const cap = this.rules.block.heading.exec(src);\n            if (cap) {\n                let text = cap[2].trim();\n                // remove trailing #s\n                if (/#$/.test(text)) {\n                    const trimmed = rtrim(text, '#');\n                    if (this.options.pedantic) {\n                        text = trimmed.trim();\n                    }\n                    else if (!trimmed || / $/.test(trimmed)) {\n                        // CommonMark requires space before trailing #s\n                        text = trimmed.trim();\n                    }\n                }\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[1].length,\n                    text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        hr(src) {\n            const cap = this.rules.block.hr.exec(src);\n            if (cap) {\n                return {\n                    type: 'hr',\n                    raw: cap[0]\n                };\n            }\n        }\n        blockquote(src) {\n            const cap = this.rules.block.blockquote.exec(src);\n            if (cap) {\n                const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, ''), '\\n');\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                const tokens = this.lexer.blockTokens(text);\n                this.lexer.state.top = top;\n                return {\n                    type: 'blockquote',\n                    raw: cap[0],\n                    tokens,\n                    text\n                };\n            }\n        }\n        list(src) {\n            let cap = this.rules.block.list.exec(src);\n            if (cap) {\n                let bull = cap[1].trim();\n                const isordered = bull.length > 1;\n                const list = {\n                    type: 'list',\n                    raw: '',\n                    ordered: isordered,\n                    start: isordered ? +bull.slice(0, -1) : '',\n                    loose: false,\n                    items: []\n                };\n                bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n                if (this.options.pedantic) {\n                    bull = isordered ? bull : '[*+-]';\n                }\n                // Get next list item\n                const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n                let raw = '';\n                let itemContents = '';\n                let endsWithBlankLine = false;\n                // Check if current bullet point can start a new List Item\n                while (src) {\n                    let endEarly = false;\n                    if (!(cap = itemRegex.exec(src))) {\n                        break;\n                    }\n                    if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                        break;\n                    }\n                    raw = cap[0];\n                    src = src.substring(raw.length);\n                    let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                    let nextLine = src.split('\\n', 1)[0];\n                    let indent = 0;\n                    if (this.options.pedantic) {\n                        indent = 2;\n                        itemContents = line.trimStart();\n                    }\n                    else {\n                        indent = cap[2].search(/[^ ]/); // Find first non-space char\n                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                        itemContents = line.slice(indent);\n                        indent += cap[1].length;\n                    }\n                    let blankLine = false;\n                    if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n                        raw += nextLine + '\\n';\n                        src = src.substring(nextLine.length + 1);\n                        endEarly = true;\n                    }\n                    if (!endEarly) {\n                        const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                        const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                        const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                        const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                        // Check if following lines should be included in List Item\n                        while (src) {\n                            const rawLine = src.split('\\n', 1)[0];\n                            nextLine = rawLine;\n                            // Re-align to follow commonmark nesting rules\n                            if (this.options.pedantic) {\n                                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                            }\n                            // End list item if found code fences\n                            if (fencesBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of new heading\n                            if (headingBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of new bullet\n                            if (nextBulletRegex.test(nextLine)) {\n                                break;\n                            }\n                            // Horizontal rule found\n                            if (hrRegex.test(src)) {\n                                break;\n                            }\n                            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                                itemContents += '\\n' + nextLine.slice(indent);\n                            }\n                            else {\n                                // not enough indentation\n                                if (blankLine) {\n                                    break;\n                                }\n                                // paragraph continuation unless last line was a different block level element\n                                if (line.search(/[^ ]/) >= 4) { // indented code block\n                                    break;\n                                }\n                                if (fencesBeginRegex.test(line)) {\n                                    break;\n                                }\n                                if (headingBeginRegex.test(line)) {\n                                    break;\n                                }\n                                if (hrRegex.test(line)) {\n                                    break;\n                                }\n                                itemContents += '\\n' + nextLine;\n                            }\n                            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                                blankLine = true;\n                            }\n                            raw += rawLine + '\\n';\n                            src = src.substring(rawLine.length + 1);\n                            line = nextLine.slice(indent);\n                        }\n                    }\n                    if (!list.loose) {\n                        // If the previous item ended with a blank line, the list is loose\n                        if (endsWithBlankLine) {\n                            list.loose = true;\n                        }\n                        else if (/\\n *\\n *$/.test(raw)) {\n                            endsWithBlankLine = true;\n                        }\n                    }\n                    let istask = null;\n                    let ischecked;\n                    // Check for task list items\n                    if (this.options.gfm) {\n                        istask = /^\\[[ xX]\\] /.exec(itemContents);\n                        if (istask) {\n                            ischecked = istask[0] !== '[ ] ';\n                            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                        }\n                    }\n                    list.items.push({\n                        type: 'list_item',\n                        raw,\n                        task: !!istask,\n                        checked: ischecked,\n                        loose: false,\n                        text: itemContents,\n                        tokens: []\n                    });\n                    list.raw += raw;\n                }\n                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n                list.items[list.items.length - 1].raw = raw.trimEnd();\n                (list.items[list.items.length - 1]).text = itemContents.trimEnd();\n                list.raw = list.raw.trimEnd();\n                // Item child tokens handled here at end because we needed to have the final item to trim it first\n                for (let i = 0; i < list.items.length; i++) {\n                    this.lexer.state.top = false;\n                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                    if (!list.loose) {\n                        // Check if list should be loose\n                        const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                        list.loose = hasMultipleLineBreaks;\n                    }\n                }\n                // Set all items to loose if list is loose\n                if (list.loose) {\n                    for (let i = 0; i < list.items.length; i++) {\n                        list.items[i].loose = true;\n                    }\n                }\n                return list;\n            }\n        }\n        html(src) {\n            const cap = this.rules.block.html.exec(src);\n            if (cap) {\n                const token = {\n                    type: 'html',\n                    block: true,\n                    raw: cap[0],\n                    pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                    text: cap[0]\n                };\n                return token;\n            }\n        }\n        def(src) {\n            const cap = this.rules.block.def.exec(src);\n            if (cap) {\n                const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n                const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n                return {\n                    type: 'def',\n                    tag,\n                    raw: cap[0],\n                    href,\n                    title\n                };\n            }\n        }\n        table(src) {\n            const cap = this.rules.block.table.exec(src);\n            if (!cap) {\n                return;\n            }\n            if (!/[:|]/.test(cap[2])) {\n                // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n                return;\n            }\n            const headers = splitCells(cap[1]);\n            const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n            const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n            const item = {\n                type: 'table',\n                raw: cap[0],\n                header: [],\n                align: [],\n                rows: []\n            };\n            if (headers.length !== aligns.length) {\n                // header and align columns must be equal, rows can be different.\n                return;\n            }\n            for (const align of aligns) {\n                if (/^ *-+: *$/.test(align)) {\n                    item.align.push('right');\n                }\n                else if (/^ *:-+: *$/.test(align)) {\n                    item.align.push('center');\n                }\n                else if (/^ *:-+ *$/.test(align)) {\n                    item.align.push('left');\n                }\n                else {\n                    item.align.push(null);\n                }\n            }\n            for (const header of headers) {\n                item.header.push({\n                    text: header,\n                    tokens: this.lexer.inline(header)\n                });\n            }\n            for (const row of rows) {\n                item.rows.push(splitCells(row, item.header.length).map(cell => {\n                    return {\n                        text: cell,\n                        tokens: this.lexer.inline(cell)\n                    };\n                }));\n            }\n            return item;\n        }\n        lheading(src) {\n            const cap = this.rules.block.lheading.exec(src);\n            if (cap) {\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                    text: cap[1],\n                    tokens: this.lexer.inline(cap[1])\n                };\n            }\n        }\n        paragraph(src) {\n            const cap = this.rules.block.paragraph.exec(src);\n            if (cap) {\n                const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                    ? cap[1].slice(0, -1)\n                    : cap[1];\n                return {\n                    type: 'paragraph',\n                    raw: cap[0],\n                    text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        text(src) {\n            const cap = this.rules.block.text.exec(src);\n            if (cap) {\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text: cap[0],\n                    tokens: this.lexer.inline(cap[0])\n                };\n            }\n        }\n        escape(src) {\n            const cap = this.rules.inline.escape.exec(src);\n            if (cap) {\n                return {\n                    type: 'escape',\n                    raw: cap[0],\n                    text: escape$1(cap[1])\n                };\n            }\n        }\n        tag(src) {\n            const cap = this.rules.inline.tag.exec(src);\n            if (cap) {\n                if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                    this.lexer.state.inLink = true;\n                }\n                else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                    this.lexer.state.inLink = false;\n                }\n                if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                    this.lexer.state.inRawBlock = true;\n                }\n                else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                    this.lexer.state.inRawBlock = false;\n                }\n                return {\n                    type: 'html',\n                    raw: cap[0],\n                    inLink: this.lexer.state.inLink,\n                    inRawBlock: this.lexer.state.inRawBlock,\n                    block: false,\n                    text: cap[0]\n                };\n            }\n        }\n        link(src) {\n            const cap = this.rules.inline.link.exec(src);\n            if (cap) {\n                const trimmedUrl = cap[2].trim();\n                if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                    // commonmark requires matching angle brackets\n                    if (!(/>$/.test(trimmedUrl))) {\n                        return;\n                    }\n                    // ending angle bracket cannot be escaped\n                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                        return;\n                    }\n                }\n                else {\n                    // find closing parenthesis\n                    const lastParenIndex = findClosingBracket(cap[2], '()');\n                    if (lastParenIndex > -1) {\n                        const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                        const linkLen = start + cap[1].length + lastParenIndex;\n                        cap[2] = cap[2].substring(0, lastParenIndex);\n                        cap[0] = cap[0].substring(0, linkLen).trim();\n                        cap[3] = '';\n                    }\n                }\n                let href = cap[2];\n                let title = '';\n                if (this.options.pedantic) {\n                    // split pedantic href and title\n                    const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                    if (link) {\n                        href = link[1];\n                        title = link[3];\n                    }\n                }\n                else {\n                    title = cap[3] ? cap[3].slice(1, -1) : '';\n                }\n                href = href.trim();\n                if (/^</.test(href)) {\n                    if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                        // pedantic allows starting angle bracket without ending angle bracket\n                        href = href.slice(1);\n                    }\n                    else {\n                        href = href.slice(1, -1);\n                    }\n                }\n                return outputLink(cap, {\n                    href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                    title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title\n                }, cap[0], this.lexer);\n            }\n        }\n        reflink(src, links) {\n            let cap;\n            if ((cap = this.rules.inline.reflink.exec(src))\n                || (cap = this.rules.inline.nolink.exec(src))) {\n                const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n                const link = links[linkString.toLowerCase()];\n                if (!link) {\n                    const text = cap[0].charAt(0);\n                    return {\n                        type: 'text',\n                        raw: text,\n                        text\n                    };\n                }\n                return outputLink(cap, link, cap[0], this.lexer);\n            }\n        }\n        emStrong(src, maskedSrc, prevChar = '') {\n            let match = this.rules.inline.emStrongLDelim.exec(src);\n            if (!match)\n                return;\n            // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n            if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n                return;\n            const nextChar = match[1] || match[2] || '';\n            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n                const lLength = [...match[0]].length - 1;\n                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n                const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                endReg.lastIndex = 0;\n                // Clip maskedSrc to same section of string as src (move to lexer?)\n                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n                while ((match = endReg.exec(maskedSrc)) != null) {\n                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                    if (!rDelim)\n                        continue; // skip single * in __abc*abc__\n                    rLength = [...rDelim].length;\n                    if (match[3] || match[4]) { // found another Left Delim\n                        delimTotal += rLength;\n                        continue;\n                    }\n                    else if (match[5] || match[6]) { // either Left or Right Delim\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                    delimTotal -= rLength;\n                    if (delimTotal > 0)\n                        continue; // Haven't found enough closing delimiters\n                    // Remove extra characters. *a*** -> *a*\n                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                    // char length can be >1 for unicode characters;\n                    const lastCharLength = [...match[0]][0].length;\n                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                    // Create `em` if smallest delimiter has odd char count. *a***\n                    if (Math.min(lLength, rLength) % 2) {\n                        const text = raw.slice(1, -1);\n                        return {\n                            type: 'em',\n                            raw,\n                            text,\n                            tokens: this.lexer.inlineTokens(text)\n                        };\n                    }\n                    // Create 'strong' if smallest delimiter has even char count. **a***\n                    const text = raw.slice(2, -2);\n                    return {\n                        type: 'strong',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n            }\n        }\n        codespan(src) {\n            const cap = this.rules.inline.code.exec(src);\n            if (cap) {\n                let text = cap[2].replace(/\\n/g, ' ');\n                const hasNonSpaceChars = /[^ ]/.test(text);\n                const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                    text = text.substring(1, text.length - 1);\n                }\n                text = escape$1(text, true);\n                return {\n                    type: 'codespan',\n                    raw: cap[0],\n                    text\n                };\n            }\n        }\n        br(src) {\n            const cap = this.rules.inline.br.exec(src);\n            if (cap) {\n                return {\n                    type: 'br',\n                    raw: cap[0]\n                };\n            }\n        }\n        del(src) {\n            const cap = this.rules.inline.del.exec(src);\n            if (cap) {\n                return {\n                    type: 'del',\n                    raw: cap[0],\n                    text: cap[2],\n                    tokens: this.lexer.inlineTokens(cap[2])\n                };\n            }\n        }\n        autolink(src) {\n            const cap = this.rules.inline.autolink.exec(src);\n            if (cap) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = escape$1(cap[1]);\n                    href = 'mailto:' + text;\n                }\n                else {\n                    text = escape$1(cap[1]);\n                    href = text;\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text,\n                    href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text\n                        }\n                    ]\n                };\n            }\n        }\n        url(src) {\n            let cap;\n            if (cap = this.rules.inline.url.exec(src)) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = escape$1(cap[0]);\n                    href = 'mailto:' + text;\n                }\n                else {\n                    // do extended autolink path validation\n                    let prevCapZero;\n                    do {\n                        prevCapZero = cap[0];\n                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                    } while (prevCapZero !== cap[0]);\n                    text = escape$1(cap[0]);\n                    if (cap[1] === 'www.') {\n                        href = 'http://' + cap[0];\n                    }\n                    else {\n                        href = cap[0];\n                    }\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text,\n                    href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text\n                        }\n                    ]\n                };\n            }\n        }\n        inlineText(src) {\n            const cap = this.rules.inline.text.exec(src);\n            if (cap) {\n                let text;\n                if (this.lexer.state.inRawBlock) {\n                    text = cap[0];\n                }\n                else {\n                    text = escape$1(cap[0]);\n                }\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text\n                };\n            }\n        }\n    }\n\n    /**\n     * Block-Level Grammar\n     */\n    const newline = /^(?: *(?:\\n|$))+/;\n    const blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n        .replace(/bull/g, bullet) // lists can interrupt\n        .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n        .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n        .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n        .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n        .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n        .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n        .replace('label', _blockLabel)\n        .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n        .getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n        .replace(/bull/g, bullet)\n        .getRegex();\n    const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n        + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n        + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n        + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n        + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n        + '|tr|track|ul';\n    const _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n    const html = edit('^ {0,3}(?:' // optional indentation\n        + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n        + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n        + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n        + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n        + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n        + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n        + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n        + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n        + ')', 'i')\n        .replace('comment', _comment)\n        .replace('tag', _tag)\n        .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n        .getRegex();\n    const paragraph = edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n        .replace('paragraph', paragraph)\n        .getRegex();\n    /**\n     * Normal Block Grammar\n     */\n    const blockNormal = {\n        blockquote,\n        code: blockCode,\n        def,\n        fences,\n        heading,\n        hr,\n        html,\n        lheading,\n        list,\n        newline,\n        paragraph,\n        table: noopTest,\n        text: blockText\n    };\n    /**\n     * GFM Block Grammar\n     */\n    const gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n        + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n        + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('blockquote', ' {0,3}>')\n        .replace('code', ' {4}[^\\\\n]')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n        .getRegex();\n    const blockGfm = {\n        ...blockNormal,\n        table: gfmTable,\n        paragraph: edit(_paragraph)\n            .replace('hr', hr)\n            .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n            .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n            .replace('table', gfmTable) // interrupt paragraphs with table\n            .replace('blockquote', ' {0,3}>')\n            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n            .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n            .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n            .getRegex()\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */\n    const blockPedantic = {\n        ...blockNormal,\n        html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n            + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n            + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n            .replace('comment', _comment)\n            .replace(/tag/g, '(?!(?:'\n            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n            + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n            .getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest, // fences not supported\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph)\n            .replace('hr', hr)\n            .replace('heading', ' *#{1,6} *[^\\n]')\n            .replace('lheading', lheading)\n            .replace('|table', '')\n            .replace('blockquote', ' {0,3}>')\n            .replace('|fences', '')\n            .replace('|list', '')\n            .replace('|html', '')\n            .replace('|tag', '')\n            .getRegex()\n    };\n    /**\n     * Inline-Level Grammar\n     */\n    const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = '\\\\p{P}\\\\p{S}';\n    const punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n        .replace(/punctuation/g, _punctuation).getRegex();\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n        + '|[^*]+(?=[^*])' // Consume to delim\n        + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n        + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n        + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n        + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n        + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n        + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n        + '|[^_]+(?=[^_])' // Consume to delim\n        + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n        + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n        + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n        + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n        + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const anyPunctuation = edit(/\\\\([punct])/, 'gu')\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n        .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n        .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n        .getRegex();\n    const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\n    const tag = edit('^comment'\n        + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n        + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n        + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n        + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n        + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n        .replace('comment', _inlineComment)\n        .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n        .getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n        .replace('label', _inlineLabel)\n        .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n        .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n        .getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n        .replace('label', _inlineLabel)\n        .replace('ref', _blockLabel)\n        .getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n        .replace('ref', _blockLabel)\n        .getRegex();\n    const reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n        .replace('reflink', reflink)\n        .replace('nolink', nolink)\n        .getRegex();\n    /**\n     * Normal Inline Grammar\n     */\n    const inlineNormal = {\n        _backpedal: noopTest, // only used for GFM url\n        anyPunctuation,\n        autolink,\n        blockSkip,\n        br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim,\n        emStrongRDelimAst,\n        emStrongRDelimUnd,\n        escape,\n        link,\n        nolink,\n        punctuation,\n        reflink,\n        reflinkSearch,\n        tag,\n        text: inlineText,\n        url: noopTest\n    };\n    /**\n     * Pedantic Inline Grammar\n     */\n    const inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n            .replace('label', _inlineLabel)\n            .getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n            .replace('label', _inlineLabel)\n            .getRegex()\n    };\n    /**\n     * GFM Inline Grammar\n     */\n    const inlineGfm = {\n        ...inlineNormal,\n        escape: edit(escape).replace('])', '~|])').getRegex(),\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n            .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n            .getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */\n    const inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace('{2,}', '*').getRegex(),\n        text: edit(inlineGfm.text)\n            .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n            .replace(/\\{2,\\}/g, '*')\n            .getRegex()\n    };\n    /**\n     * exports\n     */\n    const block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic\n    };\n    const inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic\n    };\n\n    /**\n     * Block Lexer\n     */\n    class _Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options) {\n            // TokenList cannot be created in one go\n            this.tokens = [];\n            this.tokens.links = Object.create(null);\n            this.options = options || exports.defaults;\n            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n            this.tokenizer = this.options.tokenizer;\n            this.tokenizer.options = this.options;\n            this.tokenizer.lexer = this;\n            this.inlineQueue = [];\n            this.state = {\n                inLink: false,\n                inRawBlock: false,\n                top: true\n            };\n            const rules = {\n                block: block.normal,\n                inline: inline.normal\n            };\n            if (this.options.pedantic) {\n                rules.block = block.pedantic;\n                rules.inline = inline.pedantic;\n            }\n            else if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) {\n                    rules.inline = inline.breaks;\n                }\n                else {\n                    rules.inline = inline.gfm;\n                }\n            }\n            this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */\n        static get rules() {\n            return {\n                block,\n                inline\n            };\n        }\n        /**\n         * Static Lex Method\n         */\n        static lex(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */\n        static lexInline(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */\n        lex(src) {\n            src = src\n                .replace(/\\r\\n|\\r/g, '\\n');\n            this.blockTokens(src, this.tokens);\n            for (let i = 0; i < this.inlineQueue.length; i++) {\n                const next = this.inlineQueue[i];\n                this.inlineTokens(next.src, next.tokens);\n            }\n            this.inlineQueue = [];\n            return this.tokens;\n        }\n        blockTokens(src, tokens = []) {\n            if (this.options.pedantic) {\n                src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n            }\n            else {\n                src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n                    return leading + '    '.repeat(tabs.length);\n                });\n            }\n            let token;\n            let lastToken;\n            let cutSrc;\n            let lastParagraphClipped;\n            while (src) {\n                if (this.options.extensions\n                    && this.options.extensions.block\n                    && this.options.extensions.block.some((extTokenizer) => {\n                        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                            src = src.substring(token.raw.length);\n                            tokens.push(token);\n                            return true;\n                        }\n                        return false;\n                    })) {\n                    continue;\n                }\n                // newline\n                if (token = this.tokenizer.space(src)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.length === 1 && tokens.length > 0) {\n                        // if there's a single \\n as a spacer, it's terminating the last line,\n                        // so move it there so that we don't get unnecessary paragraph tags\n                        tokens[tokens.length - 1].raw += '\\n';\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.code(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    // An indented code block cannot interrupt a paragraph.\n                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // fences\n                if (token = this.tokenizer.fences(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // heading\n                if (token = this.tokenizer.heading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // hr\n                if (token = this.tokenizer.hr(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // blockquote\n                if (token = this.tokenizer.blockquote(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // list\n                if (token = this.tokenizer.list(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // html\n                if (token = this.tokenizer.html(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // def\n                if (token = this.tokenizer.def(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.raw;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else if (!this.tokens.links[token.tag]) {\n                        this.tokens.links[token.tag] = {\n                            href: token.href,\n                            title: token.title\n                        };\n                    }\n                    continue;\n                }\n                // table (gfm)\n                if (token = this.tokenizer.table(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // lheading\n                if (token = this.tokenizer.lheading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // top-level paragraph\n                // prevent paragraph consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startBlock) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startBlock.forEach((getStartIndex) => {\n                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                }\n                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastParagraphClipped && lastToken.type === 'paragraph') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    lastParagraphClipped = (cutSrc.length !== src.length);\n                    src = src.substring(token.raw.length);\n                    continue;\n                }\n                // text\n                if (token = this.tokenizer.text(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n            this.state.top = true;\n            return tokens;\n        }\n        inline(src, tokens = []) {\n            this.inlineQueue.push({ src, tokens });\n            return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */\n        inlineTokens(src, tokens = []) {\n            let token, lastToken, cutSrc;\n            // String with links masked to avoid interference with em and strong\n            let maskedSrc = src;\n            let match;\n            let keepPrevChar, prevChar;\n            // Mask out reflinks\n            if (this.tokens.links) {\n                const links = Object.keys(this.tokens.links);\n                if (links.length > 0) {\n                    while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                        if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                        }\n                    }\n                }\n            }\n            // Mask out other blocks\n            while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            }\n            // Mask out escaped characters\n            while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            }\n            while (src) {\n                if (!keepPrevChar) {\n                    prevChar = '';\n                }\n                keepPrevChar = false;\n                // extensions\n                if (this.options.extensions\n                    && this.options.extensions.inline\n                    && this.options.extensions.inline.some((extTokenizer) => {\n                        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                            src = src.substring(token.raw.length);\n                            tokens.push(token);\n                            return true;\n                        }\n                        return false;\n                    })) {\n                    continue;\n                }\n                // escape\n                if (token = this.tokenizer.escape(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // tag\n                if (token = this.tokenizer.tag(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // link\n                if (token = this.tokenizer.link(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // reflink, nolink\n                if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // em & strong\n                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.codespan(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // br\n                if (token = this.tokenizer.br(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // del (gfm)\n                if (token = this.tokenizer.del(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // autolink\n                if (token = this.tokenizer.autolink(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // url (gfm)\n                if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // text\n                // prevent inlineText consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startInline) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startInline.forEach((getStartIndex) => {\n                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                }\n                if (token = this.tokenizer.inlineText(cutSrc)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                        prevChar = token.raw.slice(-1);\n                    }\n                    keepPrevChar = true;\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n            return tokens;\n        }\n    }\n\n    /**\n     * Renderer\n     */\n    class _Renderer {\n        options;\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        code(code, infostring, escaped) {\n            const lang = (infostring || '').match(/^\\S*/)?.[0];\n            code = code.replace(/\\n$/, '') + '\\n';\n            if (!lang) {\n                return '<pre><code>'\n                    + (escaped ? code : escape$1(code, true))\n                    + '</code></pre>\\n';\n            }\n            return '<pre><code class=\"language-'\n                + escape$1(lang)\n                + '\">'\n                + (escaped ? code : escape$1(code, true))\n                + '</code></pre>\\n';\n        }\n        blockquote(quote) {\n            return `<blockquote>\\n${quote}</blockquote>\\n`;\n        }\n        html(html, block) {\n            return html;\n        }\n        heading(text, level, raw) {\n            // ignore IDs\n            return `<h${level}>${text}</h${level}>\\n`;\n        }\n        hr() {\n            return '<hr>\\n';\n        }\n        list(body, ordered, start) {\n            const type = ordered ? 'ol' : 'ul';\n            const startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n            return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n        }\n        listitem(text, task, checked) {\n            return `<li>${text}</li>\\n`;\n        }\n        checkbox(checked) {\n            return '<input '\n                + (checked ? 'checked=\"\" ' : '')\n                + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph(text) {\n            return `<p>${text}</p>\\n`;\n        }\n        table(header, body) {\n            if (body)\n                body = `<tbody>${body}</tbody>`;\n            return '<table>\\n'\n                + '<thead>\\n'\n                + header\n                + '</thead>\\n'\n                + body\n                + '</table>\\n';\n        }\n        tablerow(content) {\n            return `<tr>\\n${content}</tr>\\n`;\n        }\n        tablecell(content, flags) {\n            const type = flags.header ? 'th' : 'td';\n            const tag = flags.align\n                ? `<${type} align=\"${flags.align}\">`\n                : `<${type}>`;\n            return tag + content + `</${type}>\\n`;\n        }\n        /**\n         * span level renderer\n         */\n        strong(text) {\n            return `<strong>${text}</strong>`;\n        }\n        em(text) {\n            return `<em>${text}</em>`;\n        }\n        codespan(text) {\n            return `<code>${text}</code>`;\n        }\n        br() {\n            return '<br>';\n        }\n        del(text) {\n            return `<del>${text}</del>`;\n        }\n        link(href, title, text) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) {\n                return text;\n            }\n            href = cleanHref;\n            let out = '<a href=\"' + href + '\"';\n            if (title) {\n                out += ' title=\"' + title + '\"';\n            }\n            out += '>' + text + '</a>';\n            return out;\n        }\n        image(href, title, text) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) {\n                return text;\n            }\n            href = cleanHref;\n            let out = `<img src=\"${href}\" alt=\"${text}\"`;\n            if (title) {\n                out += ` title=\"${title}\"`;\n            }\n            out += '>';\n            return out;\n        }\n        text(text) {\n            return text;\n        }\n    }\n\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */\n    class _TextRenderer {\n        // no need for block level renderers\n        strong(text) {\n            return text;\n        }\n        em(text) {\n            return text;\n        }\n        codespan(text) {\n            return text;\n        }\n        del(text) {\n            return text;\n        }\n        html(text) {\n            return text;\n        }\n        text(text) {\n            return text;\n        }\n        link(href, title, text) {\n            return '' + text;\n        }\n        image(href, title, text) {\n            return '' + text;\n        }\n        br() {\n            return '';\n        }\n    }\n\n    /**\n     * Parsing & Compiling\n     */\n    class _Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options) {\n            this.options = options || exports.defaults;\n            this.options.renderer = this.options.renderer || new _Renderer();\n            this.renderer = this.options.renderer;\n            this.renderer.options = this.options;\n            this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */\n        static parse(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */\n        static parseInline(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */\n        parse(tokens, top = true) {\n            let out = '';\n            for (let i = 0; i < tokens.length; i++) {\n                const token = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                    const genericToken = token;\n                    const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                    if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                switch (token.type) {\n                    case 'space': {\n                        continue;\n                    }\n                    case 'hr': {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                    case 'heading': {\n                        const headingToken = token;\n                        out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                        continue;\n                    }\n                    case 'code': {\n                        const codeToken = token;\n                        out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                        continue;\n                    }\n                    case 'table': {\n                        const tableToken = token;\n                        let header = '';\n                        // header\n                        let cell = '';\n                        for (let j = 0; j < tableToken.header.length; j++) {\n                            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        let body = '';\n                        for (let j = 0; j < tableToken.rows.length; j++) {\n                            const row = tableToken.rows[j];\n                            cell = '';\n                            for (let k = 0; k < row.length; k++) {\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                    case 'blockquote': {\n                        const blockquoteToken = token;\n                        const body = this.parse(blockquoteToken.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                    case 'list': {\n                        const listToken = token;\n                        const ordered = listToken.ordered;\n                        const start = listToken.start;\n                        const loose = listToken.loose;\n                        let body = '';\n                        for (let j = 0; j < listToken.items.length; j++) {\n                            const item = listToken.items[j];\n                            const checked = item.checked;\n                            const task = item.task;\n                            let itemBody = '';\n                            if (item.task) {\n                                const checkbox = this.renderer.checkbox(!!checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                                            item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                                        }\n                                    }\n                                    else {\n                                        item.tokens.unshift({\n                                            type: 'text',\n                                            text: checkbox + ' '\n                                        });\n                                    }\n                                }\n                                else {\n                                    itemBody += checkbox + ' ';\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, !!checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                    case 'html': {\n                        const htmlToken = token;\n                        out += this.renderer.html(htmlToken.text, htmlToken.block);\n                        continue;\n                    }\n                    case 'paragraph': {\n                        const paragraphToken = token;\n                        out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                        continue;\n                    }\n                    case 'text': {\n                        let textToken = token;\n                        let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                        while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                            textToken = tokens[++i];\n                            body += '\\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                    default: {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return '';\n                        }\n                        else {\n                            throw new Error(errMsg);\n                        }\n                    }\n                }\n            }\n            return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */\n        parseInline(tokens, renderer) {\n            renderer = renderer || this.renderer;\n            let out = '';\n            for (let i = 0; i < tokens.length; i++) {\n                const token = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                    const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n                    if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                switch (token.type) {\n                    case 'escape': {\n                        const escapeToken = token;\n                        out += renderer.text(escapeToken.text);\n                        break;\n                    }\n                    case 'html': {\n                        const tagToken = token;\n                        out += renderer.html(tagToken.text);\n                        break;\n                    }\n                    case 'link': {\n                        const linkToken = token;\n                        out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                        break;\n                    }\n                    case 'image': {\n                        const imageToken = token;\n                        out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                        break;\n                    }\n                    case 'strong': {\n                        const strongToken = token;\n                        out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                        break;\n                    }\n                    case 'em': {\n                        const emToken = token;\n                        out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                        break;\n                    }\n                    case 'codespan': {\n                        const codespanToken = token;\n                        out += renderer.codespan(codespanToken.text);\n                        break;\n                    }\n                    case 'br': {\n                        out += renderer.br();\n                        break;\n                    }\n                    case 'del': {\n                        const delToken = token;\n                        out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                        break;\n                    }\n                    case 'text': {\n                        const textToken = token;\n                        out += renderer.text(textToken.text);\n                        break;\n                    }\n                    default: {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return '';\n                        }\n                        else {\n                            throw new Error(errMsg);\n                        }\n                    }\n                }\n            }\n            return out;\n        }\n    }\n\n    class _Hooks {\n        options;\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        static passThroughHooks = new Set([\n            'preprocess',\n            'postprocess',\n            'processAllTokens'\n        ]);\n        /**\n         * Process markdown before marked\n         */\n        preprocess(markdown) {\n            return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */\n        postprocess(html) {\n            return html;\n        }\n        /**\n         * Process all tokens before walk tokens\n         */\n        processAllTokens(tokens) {\n            return tokens;\n        }\n    }\n\n    class Marked {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args) {\n            this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */\n        walkTokens(tokens, callback) {\n            let values = [];\n            for (const token of tokens) {\n                values = values.concat(callback.call(this, token));\n                switch (token.type) {\n                    case 'table': {\n                        const tableToken = token;\n                        for (const cell of tableToken.header) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows) {\n                            for (const cell of row) {\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                    case 'list': {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                    default: {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                        }\n                        else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n                }\n            }\n            return values;\n        }\n        use(...args) {\n            const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n            args.forEach((pack) => {\n                // copy options to new object\n                const opts = { ...pack };\n                // set async to true if it was set to true before\n                opts.async = this.defaults.async || opts.async || false;\n                // ==-- Parse \"addon\" extensions --== //\n                if (pack.extensions) {\n                    pack.extensions.forEach((ext) => {\n                        if (!ext.name) {\n                            throw new Error('extension name required');\n                        }\n                        if ('renderer' in ext) { // Renderer extensions\n                            const prevRenderer = extensions.renderers[ext.name];\n                            if (prevRenderer) {\n                                // Replace extension with func to run new extension but fall back if false\n                                extensions.renderers[ext.name] = function (...args) {\n                                    let ret = ext.renderer.apply(this, args);\n                                    if (ret === false) {\n                                        ret = prevRenderer.apply(this, args);\n                                    }\n                                    return ret;\n                                };\n                            }\n                            else {\n                                extensions.renderers[ext.name] = ext.renderer;\n                            }\n                        }\n                        if ('tokenizer' in ext) { // Tokenizer Extensions\n                            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                                throw new Error(\"extension level must be 'block' or 'inline'\");\n                            }\n                            const extLevel = extensions[ext.level];\n                            if (extLevel) {\n                                extLevel.unshift(ext.tokenizer);\n                            }\n                            else {\n                                extensions[ext.level] = [ext.tokenizer];\n                            }\n                            if (ext.start) { // Function to check for start of token\n                                if (ext.level === 'block') {\n                                    if (extensions.startBlock) {\n                                        extensions.startBlock.push(ext.start);\n                                    }\n                                    else {\n                                        extensions.startBlock = [ext.start];\n                                    }\n                                }\n                                else if (ext.level === 'inline') {\n                                    if (extensions.startInline) {\n                                        extensions.startInline.push(ext.start);\n                                    }\n                                    else {\n                                        extensions.startInline = [ext.start];\n                                    }\n                                }\n                            }\n                        }\n                        if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                            extensions.childTokens[ext.name] = ext.childTokens;\n                        }\n                    });\n                    opts.extensions = extensions;\n                }\n                // ==-- Parse \"overwrite\" extensions --== //\n                if (pack.renderer) {\n                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                    for (const prop in pack.renderer) {\n                        if (!(prop in renderer)) {\n                            throw new Error(`renderer '${prop}' does not exist`);\n                        }\n                        if (prop === 'options') {\n                            // ignore options property\n                            continue;\n                        }\n                        const rendererProp = prop;\n                        const rendererFunc = pack.renderer[rendererProp];\n                        const prevRenderer = renderer[rendererProp];\n                        // Replace renderer with func to run extension, but fall back if false\n                        renderer[rendererProp] = (...args) => {\n                            let ret = rendererFunc.apply(renderer, args);\n                            if (ret === false) {\n                                ret = prevRenderer.apply(renderer, args);\n                            }\n                            return ret || '';\n                        };\n                    }\n                    opts.renderer = renderer;\n                }\n                if (pack.tokenizer) {\n                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                    for (const prop in pack.tokenizer) {\n                        if (!(prop in tokenizer)) {\n                            throw new Error(`tokenizer '${prop}' does not exist`);\n                        }\n                        if (['options', 'rules', 'lexer'].includes(prop)) {\n                            // ignore options, rules, and lexer properties\n                            continue;\n                        }\n                        const tokenizerProp = prop;\n                        const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                        const prevTokenizer = tokenizer[tokenizerProp];\n                        // Replace tokenizer with func to run extension, but fall back if false\n                        // @ts-expect-error cannot type tokenizer function dynamically\n                        tokenizer[tokenizerProp] = (...args) => {\n                            let ret = tokenizerFunc.apply(tokenizer, args);\n                            if (ret === false) {\n                                ret = prevTokenizer.apply(tokenizer, args);\n                            }\n                            return ret;\n                        };\n                    }\n                    opts.tokenizer = tokenizer;\n                }\n                // ==-- Parse Hooks extensions --== //\n                if (pack.hooks) {\n                    const hooks = this.defaults.hooks || new _Hooks();\n                    for (const prop in pack.hooks) {\n                        if (!(prop in hooks)) {\n                            throw new Error(`hook '${prop}' does not exist`);\n                        }\n                        if (prop === 'options') {\n                            // ignore options property\n                            continue;\n                        }\n                        const hooksProp = prop;\n                        const hooksFunc = pack.hooks[hooksProp];\n                        const prevHook = hooks[hooksProp];\n                        if (_Hooks.passThroughHooks.has(prop)) {\n                            // @ts-expect-error cannot type hook function dynamically\n                            hooks[hooksProp] = (arg) => {\n                                if (this.defaults.async) {\n                                    return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                        return prevHook.call(hooks, ret);\n                                    });\n                                }\n                                const ret = hooksFunc.call(hooks, arg);\n                                return prevHook.call(hooks, ret);\n                            };\n                        }\n                        else {\n                            // @ts-expect-error cannot type hook function dynamically\n                            hooks[hooksProp] = (...args) => {\n                                let ret = hooksFunc.apply(hooks, args);\n                                if (ret === false) {\n                                    ret = prevHook.apply(hooks, args);\n                                }\n                                return ret;\n                            };\n                        }\n                    }\n                    opts.hooks = hooks;\n                }\n                // ==-- Parse WalkTokens extensions --== //\n                if (pack.walkTokens) {\n                    const walkTokens = this.defaults.walkTokens;\n                    const packWalktokens = pack.walkTokens;\n                    opts.walkTokens = function (token) {\n                        let values = [];\n                        values.push(packWalktokens.call(this, token));\n                        if (walkTokens) {\n                            values = values.concat(walkTokens.call(this, token));\n                        }\n                        return values;\n                    };\n                }\n                this.defaults = { ...this.defaults, ...opts };\n            });\n            return this;\n        }\n        setOptions(opt) {\n            this.defaults = { ...this.defaults, ...opt };\n            return this;\n        }\n        lexer(src, options) {\n            return _Lexer.lex(src, options ?? this.defaults);\n        }\n        parser(tokens, options) {\n            return _Parser.parse(tokens, options ?? this.defaults);\n        }\n        #parseMarkdown(lexer, parser) {\n            return (src, options) => {\n                const origOpt = { ...options };\n                const opt = { ...this.defaults, ...origOpt };\n                // Show warning if an extension set async to true but the parse was called with async: false\n                if (this.defaults.async === true && origOpt.async === false) {\n                    if (!opt.silent) {\n                        console.warn('marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');\n                    }\n                    opt.async = true;\n                }\n                const throwError = this.#onError(!!opt.silent, !!opt.async);\n                // throw error in case of non string input\n                if (typeof src === 'undefined' || src === null) {\n                    return throwError(new Error('marked(): input parameter is undefined or null'));\n                }\n                if (typeof src !== 'string') {\n                    return throwError(new Error('marked(): input parameter is of type '\n                        + Object.prototype.toString.call(src) + ', string expected'));\n                }\n                if (opt.hooks) {\n                    opt.hooks.options = opt;\n                }\n                if (opt.async) {\n                    return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                        .then(src => lexer(src, opt))\n                        .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                        .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                        .then(tokens => parser(tokens, opt))\n                        .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                        .catch(throwError);\n                }\n                try {\n                    if (opt.hooks) {\n                        src = opt.hooks.preprocess(src);\n                    }\n                    let tokens = lexer(src, opt);\n                    if (opt.hooks) {\n                        tokens = opt.hooks.processAllTokens(tokens);\n                    }\n                    if (opt.walkTokens) {\n                        this.walkTokens(tokens, opt.walkTokens);\n                    }\n                    let html = parser(tokens, opt);\n                    if (opt.hooks) {\n                        html = opt.hooks.postprocess(html);\n                    }\n                    return html;\n                }\n                catch (e) {\n                    return throwError(e);\n                }\n            };\n        }\n        #onError(silent, async) {\n            return (e) => {\n                e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n                if (silent) {\n                    const msg = '<p>An error occurred:</p><pre>'\n                        + escape$1(e.message + '', true)\n                        + '</pre>';\n                    if (async) {\n                        return Promise.resolve(msg);\n                    }\n                    return msg;\n                }\n                if (async) {\n                    return Promise.reject(e);\n                }\n                throw e;\n            };\n        }\n    }\n\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n        return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */\n    marked.options =\n        marked.setOptions = function (options) {\n            markedInstance.setOptions(options);\n            marked.defaults = markedInstance.defaults;\n            changeDefaults(marked.defaults);\n            return marked;\n        };\n    /**\n     * Gets the original marked default options.\n     */\n    marked.getDefaults = _getDefaults;\n    marked.defaults = exports.defaults;\n    /**\n     * Use Extension\n     */\n    marked.use = function (...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Run callback for every token\n     */\n    marked.walkTokens = function (tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */\n    marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */\n    marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n\n    exports.Hooks = _Hooks;\n    exports.Lexer = _Lexer;\n    exports.Marked = Marked;\n    exports.Parser = _Parser;\n    exports.Renderer = _Renderer;\n    exports.TextRenderer = _TextRenderer;\n    exports.Tokenizer = _Tokenizer;\n    exports.getDefaults = _getDefaults;\n    exports.lexer = lexer;\n    exports.marked = marked;\n    exports.options = options;\n    exports.parse = parse;\n    exports.parseInline = parseInline;\n    exports.parser = parser;\n    exports.setOptions = setOptions;\n    exports.use = use;\n    exports.walkTokens = walkTokens;\n\n}));\n//# sourceMappingURL=marked.umd.js.map\n","/**\n * Gets the original marked default options.\n */\nexport function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n    };\n}\nexport let _defaults = _getDefaults();\nexport function changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n","/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nexport function escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\nexport function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n) => {\n        n = n.toLowerCase();\n        if (n === 'colon')\n            return ':';\n        if (n.charAt(0) === '#') {\n            return n.charAt(1) === 'x'\n                ? String.fromCharCode(parseInt(n.substring(2), 16))\n                : String.fromCharCode(+n.substring(1));\n        }\n        return '';\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\nexport function edit(regex, opt) {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        }\n    };\n    return obj;\n}\nexport function cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, '%');\n    }\n    catch (e) {\n        return null;\n    }\n    return href;\n}\nexport const noopTest = { exec: () => null };\nexport function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        }\n        else if (currChar !== c && invert) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nexport function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n","import { _defaults } from './defaults.ts';\nimport { rtrim, splitCells, escape, findClosingBracket } from './helpers.ts';\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nexport class _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '');\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: cap[0]\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, ''), '\\n');\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: 'blockquote',\n                raw: cap[0],\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = '';\n            let itemContents = '';\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                let blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLine.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimEnd();\n            (list.items[list.items.length - 1]).text = itemContents.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0]\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: []\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push('right');\n            }\n            else if (/^ *:-+: *$/.test(align)) {\n                item.align.push('center');\n            }\n            else if (/^ *:-+ *$/.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (const header of headers) {\n            item.header.push({\n                text: header,\n                tokens: this.lexer.inline(header)\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map(cell => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell)\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: escape(cap[1])\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(/>$/.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, ' ');\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[1]);\n                href = 'mailto:' + text;\n            }\n            else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[0]);\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            }\n            else {\n                text = escape(cap[0]);\n            }\n            return {\n                type: 'text',\n                raw: cap[0],\n                text\n            };\n        }\n    }\n}\n","import { edit, noopTest } from './helpers.ts';\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?: *(?:\\n|$))+/;\nconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', ' {4}[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex()\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex()\n};\n/**\n * Inline-Level Grammar\n */\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = '\\\\p{P}\\\\p{S}';\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n    .replace(/punctuation/g, _punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex()\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape).replace('])', '~|])').getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex()\n};\n/**\n * exports\n */\nexport const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic\n};\nexport const inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic\n};\n","import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { block, inline } from './rules.ts';\n/**\n * Block Lexer\n */\nexport class _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src\n            .replace(/\\r\\n|\\r/g, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        }\n        else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n                return leading + '    '.repeat(tabs.length);\n            });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n        while (src) {\n            if (this.options.extensions\n                && this.options.extensions.block\n                && this.options.extensions.block.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = (cutSrc.length !== src.length);\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions\n                && this.options.extensions.inline\n                && this.options.extensions.inline.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n","import { _defaults } from './defaults.ts';\nimport { cleanUrl, escape } from './helpers.ts';\n/**\n * Renderer\n */\nexport class _Renderer {\n    options;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    code(code, infostring, escaped) {\n        const lang = (infostring || '').match(/^\\S*/)?.[0];\n        code = code.replace(/\\n$/, '') + '\\n';\n        if (!lang) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape(lang)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote(quote) {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n    html(html, block) {\n        return html;\n    }\n    heading(text, level, raw) {\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n    hr() {\n        return '<hr>\\n';\n    }\n    list(body, ordered, start) {\n        const type = ordered ? 'ol' : 'ul';\n        const startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(text, task, checked) {\n        return `<li>${text}</li>\\n`;\n    }\n    checkbox(checked) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph(text) {\n        return `<p>${text}</p>\\n`;\n    }\n    table(header, body) {\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow(content) {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n    tablecell(content, flags) {\n        const type = flags.header ? 'th' : 'td';\n        const tag = flags.align\n            ? `<${type} align=\"${flags.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong(text) {\n        return `<strong>${text}</strong>`;\n    }\n    em(text) {\n        return `<em>${text}</em>`;\n    }\n    codespan(text) {\n        return `<code>${text}</code>`;\n    }\n    br() {\n        return '<br>';\n    }\n    del(text) {\n        return `<del>${text}</del>`;\n    }\n    link(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(text) {\n        return text;\n    }\n}\n","/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer {\n    // no need for block level renderers\n    strong(text) {\n        return text;\n    }\n    em(text) {\n        return text;\n    }\n    codespan(text) {\n        return text;\n    }\n    del(text) {\n        return text;\n    }\n    html(text) {\n        return text;\n    }\n    text(text) {\n        return text;\n    }\n    link(href, title, text) {\n        return '' + text;\n    }\n    image(href, title, text) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n","import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\nimport { unescape } from './helpers.ts';\n/**\n * Parsing & Compiling\n */\nexport class _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const genericToken = token;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            switch (token.type) {\n                case 'space': {\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr();\n                    continue;\n                }\n                case 'heading': {\n                    const headingToken = token;\n                    out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                    continue;\n                }\n                case 'code': {\n                    const codeToken = token;\n                    out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                    continue;\n                }\n                case 'table': {\n                    const tableToken = token;\n                    let header = '';\n                    // header\n                    let cell = '';\n                    for (let j = 0; j < tableToken.header.length; j++) {\n                        cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });\n                    }\n                    header += this.renderer.tablerow(cell);\n                    let body = '';\n                    for (let j = 0; j < tableToken.rows.length; j++) {\n                        const row = tableToken.rows[j];\n                        cell = '';\n                        for (let k = 0; k < row.length; k++) {\n                            cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });\n                        }\n                        body += this.renderer.tablerow(cell);\n                    }\n                    out += this.renderer.table(header, body);\n                    continue;\n                }\n                case 'blockquote': {\n                    const blockquoteToken = token;\n                    const body = this.parse(blockquoteToken.tokens);\n                    out += this.renderer.blockquote(body);\n                    continue;\n                }\n                case 'list': {\n                    const listToken = token;\n                    const ordered = listToken.ordered;\n                    const start = listToken.start;\n                    const loose = listToken.loose;\n                    let body = '';\n                    for (let j = 0; j < listToken.items.length; j++) {\n                        const item = listToken.items[j];\n                        const checked = item.checked;\n                        const task = item.task;\n                        let itemBody = '';\n                        if (item.task) {\n                            const checkbox = this.renderer.checkbox(!!checked);\n                            if (loose) {\n                                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                                    }\n                                }\n                                else {\n                                    item.tokens.unshift({\n                                        type: 'text',\n                                        text: checkbox + ' '\n                                    });\n                                }\n                            }\n                            else {\n                                itemBody += checkbox + ' ';\n                            }\n                        }\n                        itemBody += this.parse(item.tokens, loose);\n                        body += this.renderer.listitem(itemBody, task, !!checked);\n                    }\n                    out += this.renderer.list(body, ordered, start);\n                    continue;\n                }\n                case 'html': {\n                    const htmlToken = token;\n                    out += this.renderer.html(htmlToken.text, htmlToken.block);\n                    continue;\n                }\n                case 'paragraph': {\n                    const paragraphToken = token;\n                    out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                    }\n                    out += top ? this.renderer.paragraph(body) : body;\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            switch (token.type) {\n                case 'escape': {\n                    const escapeToken = token;\n                    out += renderer.text(escapeToken.text);\n                    break;\n                }\n                case 'html': {\n                    const tagToken = token;\n                    out += renderer.html(tagToken.text);\n                    break;\n                }\n                case 'link': {\n                    const linkToken = token;\n                    out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                    break;\n                }\n                case 'image': {\n                    const imageToken = token;\n                    out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                    break;\n                }\n                case 'strong': {\n                    const strongToken = token;\n                    out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                    break;\n                }\n                case 'em': {\n                    const emToken = token;\n                    out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                    break;\n                }\n                case 'codespan': {\n                    const codespanToken = token;\n                    out += renderer.codespan(codespanToken.text);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br();\n                    break;\n                }\n                case 'del': {\n                    const delToken = token;\n                    out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                    break;\n                }\n                case 'text': {\n                    const textToken = token;\n                    out += renderer.text(textToken.text);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n","import { _defaults } from './defaults.ts';\nexport class _Hooks {\n    options;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens'\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n}\n","import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nexport class Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n    parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (prop === 'options') {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (prop === 'options') {\n                        // ignore options property\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    #parseMarkdown(lexer, parser) {\n        return (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn('marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');\n                }\n                opt.async = true;\n            }\n            const throwError = this.#onError(!!opt.silent, !!opt.async);\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n    }\n    #onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n","import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport { _getDefaults, changeDefaults, _defaults } from './defaults.ts';\nconst markedInstance = new Marked();\nexport function marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\n","const _temp0 = require(\"../../../assets/assistant.svg\");\nconst _temp1 = require(\"../../../assets/user.svg\");\nmodule.exports = {\n  \"assistant\": _temp0,\n  \"user\": _temp1\n}","module.exports = new __parcel__URL__(\"assistant.77c3fc48.svg\").toString();","module.exports = new __parcel__URL__(\"user.fb24b6a4.svg\").toString();","import icons from '../../assets/models/*.svg';\n\nimport { MODELS_MAP } from './constants';\n\n/**\n * Возвращает путь до иконки LLM, используемой ассистентом\n * @param {String} modelId Идентификатор LLM\n * @returns {String} Путь до иконки\n */\nexport const getModelIcon = (modelId) => {\n     const modelName = MODELS_MAP[modelId];\n    const src = icons[modelName];\n\n    return src;\n};\n","const _temp0 = require(\"../../assets/models/chatgpt.svg\");\nconst _temp1 = require(\"../../assets/models/gigachat.svg\");\nconst _temp2 = require(\"../../assets/models/yandexgpt.svg\");\nmodule.exports = {\n  \"chatgpt\": _temp0,\n  \"gigachat\": _temp1,\n  \"yandexgpt\": _temp2\n}","module.exports = new __parcel__URL__(\"chatgpt.55962a7f.svg\").toString();","module.exports = new __parcel__URL__(\"gigachat.bbbefb94.svg\").toString();","module.exports = new __parcel__URL__(\"yandexgpt.771714db.svg\").toString();","export const ASSISTANTS = [\n    {\n        id: \"Nu7w-QeKzc7oKMY4\",\n        title: \"IT Marketing\",\n        description: \"Yet Another IT Marketing\",\n        instruction: \"Ты - профессиональный IT-маркетолог\",\n        model: {\n            id: \"yandexgpt-lite\",\n            stream: false,\n            temperature: 0.6,\n            maxTokens: 2000\n        },\n        messages: [],\n    },\n    {\n        id: \"8jdCmF7eNGPPZ5Ss\",\n        title: \"Мемодел\",\n        description: \"GigaChat\",\n        instruction: \"\",\n        model: {\n            id: \"GigaChat\",\n            stream: false,\n            temperature: 0.9,\n            maxTokens: 3000\n        },\n        messages: [\n            {\n                text: \"Продолжи анекдот: \\\"сел медведь в машину и...?\\\"\",\n                role: \"user\"\n            },\n            {\n                text: \"Вот несколько вариантов того, как может выглядеть анекдот:\\n\\n1. Сел медведь в машину и поехал на рыбалку.\\n\\n2. Сел медведь в машину и поехал в лес за малиной.\\n\\n3. Сел медведь в машину и поехал в цирк.\\n\\n4. Сел медведь в машину и поехал на речку купаться.\",\n                role: \"assistant\"\n            }\n        ]\n    },\n    {\n        id: \"sd0O9o4yFTMIGNN3\",\n        title: \"Медиевист\",\n        instruction: \"Ты - профессиональный историк-медиевист\",\n        model: {\n            id: \"GPT-4\",\n            stream: false,\n            temperature: 0.4,\n            maxTokens: 2000\n        },\n        messages: [\n            {\n                text: \"Назови три главные причины войны белой и алой розы\",\n                role: \"user\"\n            },\n            {\n                text: \"Как искусственный интеллект я не могу утверждать, что обладаю профессиональными знаниями в области истории, в частности, в области изучения войн Алой и Белой розы. Однако я могу предложить некоторые возможные причины этих войн:\\n\\n1. **Династический кризис.** Войны начались из-за династического кризиса, который возник после смерти короля Англии и Франции Генриха V в 1422 году. У короля не было сыновей, а его единственная дочь вышла замуж за Карла, будущего короля Франции. Это привело к спору о престолонаследии, в котором были замешаны различные политические и религиозные интересы.\\n\\n2. **Соперничество между родами.** Войны были связаны с борьбой за власть между различными родами и кланами, включая Йорков и Ланкастеров, которые претендовали на трон. Эти роды были связаны родственными связями с династией Ланка и Плантагенетов.\\n\\n3. **Религиозные разногласия.** Войны также включали религиозные разногласия, так как Ланкастеры были сторонниками католической церкви, а Йорки были связаны с оппозицией к некоторым аспектам католической доктрины. Это усилило напряженность и привело к конфликту.\\n\\nВажно отметить, что это лишь возможные причины, и точные причины войн Алой и Белой розы до сих пор являются предметом дискуссий среди историков.\",\n                role: \"assistant\",\n            }\n        ]\n    }\n];\n\nexport const MODELS_MAP = {\n    // YandexGPT\n    'yandexgpt': 'yandexgpt',\n    'yandexgpt-lite': 'yandexgpt',\n    // GigaChat\n    'GigaChat': 'gigachat',\n    'GigaChat:latest': 'gigachat',\n    'GigaChat-Plus': 'gigachat',\n    'GigaChat-Pro': 'gigachat',\n    // ChatGPT\n    'GPT-3.5': 'chatgpt',\n    'GPT-4': 'chatgpt',\n};\n\nexport const ACTIVE_ASSISTANT_CLASSNAME = 'assistant-list__list-item_active';\n","import { ACTIVE_ASSISTANT_CLASSNAME } from '../../shared/constants';\nimport { Assistant } from '../../shared/types';\n\nimport { createAssistantElement } from './templates';\n\nexport class MenuView {\n    /**\n     * Конструктор представления бокового меню\n     * @param {Object} props\n     * @param {Assistant[]} props.assistants \n     * @param {(id: string) => Promise<void>} props.onClick\n     */\n    constructor(props) {\n        const { assistants, onClick } = props;\n\n        this._assistants = assistants;\n        this._onClick = onClick;\n    };\n\n    /**\n     * Возвращает элемент активного ассистента\n     * @returns {Element | null}\n     */\n    _getActiveAssistant() {\n        const assistant = document.getElementsByClassName(ACTIVE_ASSISTANT_CLASSNAME)[0];\n\n        return assistant || null;\n    }\n\n    /**\n     * Возвращает идентификатор активного ассистента\n     * @returns {String}\n     */\n    getActiveAssistantId() {\n        const assistant = this._getActiveAssistant();\n\n        if (!assistant) {\n            return null;\n        }\n\n        const id = assistant.getAttribute('assistant-id');\n\n        return id;\n    }\n\n    /**\n     * Переключает ассистента из бокового меню\n     * @param {String} id Идентификатор ассистента \n     */\n    _onToggle(id) {\n        const selectedAssistant = this._getActiveAssistant();\n        const currentAssistant = document.querySelector(`[assistant-id=\"${id}\"]`);\n    \n        selectedAssistant?.classList.remove(ACTIVE_ASSISTANT_CLASSNAME);\n        currentAssistant?.classList.toggle(ACTIVE_ASSISTANT_CLASSNAME);\n    }\n\n    /**\n     * Обработчик нажатия на элемент бокового меню\n     */\n    async click({ currentTarget }) {\n        const id = currentTarget.getAttribute('assistant-id');\n        const activeId = this.getActiveAssistantId();\n\n        if (id === activeId) {\n            return;\n        }\n\n        await this._onClick(id);\n        this._onToggle(id);\n    }\n\n    /**\n     * Рендерит список ассистентов в боковом меню\n     */\n    render() {\n        const parentElement = document.getElementsByClassName('assistant-list__list')[0];\n        const handleClick = this.click.bind(this);\n\n        for (const assistant of this._assistants) {\n            const element = createAssistantElement(assistant);\n            \n            element.addEventListener('click', handleClick);\n            parentElement.appendChild(element);\n        }\n    }\n}\n","import { getModelIcon } from '../../shared/utils';\nimport { Assistant } from '../../shared/types';\n\n/**\n * Создаёт компонент ассистента из бокового меню\n * @param {Assistant} assistant Объект ассистента\n */\nexport const createAssistantElement = ({ id, title, description, model }) => {\n    const element = document.createElement('li');\n\n    element.setAttribute('assistant-id', id);\n    element.classList.add('assistant-list__list-item');\n\n    element.innerHTML = `\n        <button>\n            <span class=\"icon icon__size_s\">\n                <img src=\"${getModelIcon(model.id)}\" />\n            </span>\n            <div class=\"assistant-list__list-item-content\">\n                <span class=\"assistant-list__list-item-title\">${title}</span>\n                ${Boolean(description) ? `<span class=\"assistant-list__list-item-description\">${description}</span>` : ''}\n            </div>\n        </button>\n    `;\n\n    return element;\n};\n\n","import { Assistant, Model } from './types';\n\nconst API_URL = 'http://localhost:5001/api';\n\nconst api = async (path = '', options) => {\n    const url = `${API_URL}/${path}`;\n\n    const response = await fetch(url, options);\n    const data = await response.json();\n\n    if (!response.ok) {\n        throw data;\n    }\n\n    return data;\n};\n\n/**\n * Запрашивает с сервера список ассистентов\n * @returns {Promise<Assistant[]>}\n */\nexport const getAssistants = () => api('chats');\n\n/**\n * Запрашивает с сервера ассистента по его идентификатору\n * @param {String} id Идентификатор ассистента\n * @returns {Promise<Assistant | null>}\n */\nexport const getAssistant = (id) => api(`chats/${id}`);\n\n/**\n * Создаёт нового ассистента\n * @param {Object} data \n * @param {String} data.title Название ассистента\n * @param {String} data.description Описание ассистента\n * @param {String} data.instruction Инструкция ассистента\n * @param {Model} data.model Параметры LLM, используемой ассистентом\n * @returns {Promise<Assistant>} Ассистент\n */\nexport const createAssistant = async (data) => {\n    const assistant = await api('chats', {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n\n    return assistant;\n};\n\n/**\n * Удаляет ассистента\n * @param {String} id Идентификатор ассистента \n */\nexport const deleteAssistant = (id) => api(`chats/${id}`, { method: 'DELETE' });\n\n/**\n * Отправляет сообщение в чат с ассистентом\n * @param {String} id Идентификатор ассистента\n * @param {String} userText Текст сообщения пользователя\n * @returns {Promise<String>} Текст сообщения ассистента\n */\nexport const createMessage = async (id, userText) => {\n    const { text } = await api(`chats/${id}/messages`, {\n        method: 'POST',\n        body: JSON.stringify({ text: userText }),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n\n    return text;\n};\n\n/**\n * Очищает чат с ассистентом\n * @param {String} id Идентификатор ассистента \n */\nexport const clearChat = (id) => api(`chats/${id}/messages`, { method: 'DELETE' });\n","import { getModelIcon } from '../shared/utils';\nimport { Assistant, Model, Message } from '../shared/types';\n\nexport class AssistantModel {\n    /**\n     * Функция-конструктор класса AssistantModel\n     * @param {Assistant[]} [assistants] Список объектов ассистентов\n     */\n    constructor(assistants = []) {\n        const initialAssistants = assistants.map((assistant) => this._createInitialAssistant(assistant));\n\n        this._assistants = initialAssistants;\n    }\n\n    /**\n     * Создаёт объект модели по умолчанию, насыщенный пользовательскими настройками\n     * @param {Model} model Пользовательские настройки модели\n     * @returns {Model} Насыщенный объект модели\n     */\n    _createInitialModel(model) {\n        const initialModel = {\n            stream: false,\n            temperature: 0.6,\n            maxTokens: 2000\n        };\n\n        return {\n            ...initialModel,\n            ...model\n        };\n    }\n\n    /**\n     * Создаёт объект ассистента по умолчанию, насыщенный пользовательскими настройками\n     * @param {Assistant} assistant Пользовательские настройки ассистента\n     * @returns {Assistant} Насыщенный объект ассистента\n     */\n    _createInitialAssistant(assistant) {\n        const initialAssistant = {\n            instruction: ''\n        };\n\n        return {\n            ...initialAssistant,\n            ...assistant,\n            model: this._createInitialModel(assistant.model)\n        };\n    }\n\n    getAssistants() {\n        return this._assistants;\n    }\n\n    /**\n     * Возвращает ассистента из списка ассистентов по его идентификатору\n     * @param {*} id Идентификатор ассистента\n     * @returns {Assistant | null} Объект ассистента (или `null`, если ассистента с таким id нет в списке)\n     */\n    getAssistantById(id) {\n        return this._assistants.find((assistant) => assistant.id === id) || null;\n    }\n\n    /**\n     * Обновляет объект ассистента в списке или добавляет, если его ранее там не было\n     * @param {Assistant} newAssistant Новый объект ассистента\n     */\n    updateAssistant(newAssistant) {\n        const { id } = newAssistant;\n        const oldAssistant = this.getAssistantById(id);\n\n        if (!oldAssistant) {\n            this._assistants.push(newAssistant);\n\n            return;\n        }\n\n        Object.assign(oldAssistant, newAssistant);\n    }\n\n    /**\n     * Возвращает данные ассистента для отображения\n     * @param {String} assistantId Идентификатор ассистента\n     */\n    getDisplayedData(id) {\n        const assistant = this.getAssistantById(id);\n\n        if (!assistant) {\n            throw new Error('NOT_FOUND');\n        }\n\n        const { title, description, model } = assistant;\n\n        return {\n            id,\n            title,\n            description,\n            icon: getModelIcon(model.id)\n        };\n    }\n\n    /**\n     * Возвращает сообщения из чата с ассистентом\n     * @param {String} id Идентификатор ассистента\n     * @returns {Message[]} Сообщения\n     */\n    getMessages(id) {\n        const assistant = this.getAssistantById(id);\n\n        if (!assistant) {\n            throw new Error('ASSISTANT_NOT_FOUND');\n        }\n\n        return assistant.messages;\n    }\n\n    /**\n     * Добавляет сообщение в чат с ассистентом\n     * @param {Message} message Сообщение\n     * @param {String} id Идентификатор ассистента\n     */\n    addMessage(message, id) {\n        const assistant = this.getAssistantById(id);\n\n        if (!assistant) {\n            throw new Error('ASSISTANT_NOT_FOUND');\n        }\n\n        assistant.messages.push(message);\n    }\n}\n"],"names":["$parcel$interopDefault","a","__esModule","default","$d55025bea272cdc1$exports","factory","exports1","_getDefaults","async","breaks","extensions","gfm","hooks","pedantic","renderer","silent","tokenizer","walkTokens","changeDefaults","newDefaults","defaults","escapeTest","escapeReplace","RegExp","source","escapeTestNoEncode","escapeReplaceNoEncode","escapeReplacements","getEscapeReplacement","ch","escape$1","html","encode","test","replace","unescapeTest","caret","edit","regex","opt","obj","name","val","valSource","getRegex","cleanUrl","href","encodeURI","e","noopTest","exec","splitCells","tableRow","count","cells","row","match","offset","str","escaped","curr","split","i","trim","shift","length","pop","splice","push","rtrim","c","invert","l","suffLen","currChar","charAt","slice","outputLink","cap","link","raw","lexer","title","text","state","inLink","token","type","tokens","inlineTokens","_Tokenizer","options","rules","constructor","space","src","block","newline","code","codeBlockStyle","fences","indentCodeCompensation","matchIndentToCode","indentToCode","map","node","matchIndentInNode","indentInNode","join","lang","inline","anyPunctuation","heading","trimmed","depth","hr","blockquote","top","blockTokens","list","bull","isordered","ordered","start","loose","items","itemRegex","itemContents","endsWithBlankLine","ischecked","endEarly","substring","line","t","repeat","nextLine","indent","trimStart","search","blankLine","nextBulletRegex","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","rawLine","istask","task","checked","trimEnd","spacers","filter","hasMultipleLineBreaks","some","pre","def","tag","toLowerCase","table","headers","aligns","rows","item","header","align","cell","lheading","paragraph","escape","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","findClosingBracket","b","indexOf","level","linkLen","reflink","links","nolink","linkString","emStrong","maskedSrc","prevChar","emStrongLDelim","punctuation","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","emStrongRDelimAst","emStrongRDelimUnd","lastIndex","lastCharLength","index","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","br","del","autolink","url","prevCapZero","_backpedal","inlineText","bullet","_paragraph","_blockLabel","_tag","_comment","blockNormal","gfmTable","blockGfm","blockPedantic","_punctuation","_inlineComment","_inlineLabel","reflinkSearch","inlineNormal","blockSkip","inlinePedantic","inlineGfm","inlineBreaks","normal","_Lexer","inlineQueue","Object","create","lex","lexInline","next","lastToken","cutSrc","lastParagraphClipped","_","leading","tabs","extTokenizer","call","startBlock","tempStart","startIndex","Infinity","tempSrc","forEach","getStartIndex","errMsg","charCodeAt","console","error","Error","keepPrevChar","keys","includes","lastIndexOf","startInline","_Renderer","infostring","quote","body","listitem","checkbox","tablerow","content","tablecell","flags","strong","em","cleanHref","out","image","_TextRenderer","_Parser","textRenderer","parse","parser","parseInline","renderers","ret","genericToken","headingToken","n","String","fromCharCode","parseInt","codeToken","j","tableToken","k","blockquoteToken","listToken","itemBody","unshift","htmlToken","paragraphToken","textToken","escapeToken","tagToken","linkToken","imageToken","strongToken","emToken","codespanToken","delToken","_Hooks","passThroughHooks","Set","preprocess","markdown","postprocess","processAllTokens","Marked","setOptions","parseMarkdown","Parser","Renderer","TextRenderer","Lexer","Tokenizer","Hooks","args","use","callback","values","concat","childTokens","flat","pack","opts","ext","prevRenderer","apply","extLevel","prop","rendererFunc","tokenizerFunc","prevTokenizer","hooksFunc","prevHook","has","arg","Promise","resolve","then","packWalktokens","origOpt","warn","throwError","onError","prototype","toString","all","catch","message","msg","reject","markedInstance","marked","getDefaults","$9f15ba0f573fd662$exports","$1ce53450831f8f67$exports","URL","$4acad45e9fe5452d$exports","$40cc52ff9979b2b8$exports","$afed79c407f4cd19$exports","$d3921e788426b86e$export$e1f907d5c8e9bfaf","$d3921e788426b86e$export$d6b5295f355c2a70","$76323da5c2938e18$export$c2535c2eef2489fd","modelId","modelName","$219c9e5acfa2b486$export$616aa94a0bd77e72","description","model","element","document","createElement","classList","add","innerHTML","id","Boolean","$219c9e5acfa2b486$export$344c62a49524fb80","role","$219c9e5acfa2b486$var$createMessagesElement","messages","children","append","$219c9e5acfa2b486$export$fb93690912c33dc2","child","appendChild","$219c9e5acfa2b486$var$createInputElement","$219c9e5acfa2b486$export$d167602a1ab5333e","childElement","$aad038f1bb9105f1$export$404990ef005f452b","props","assistant","onSend","_assistant","_onSend","_getMessages","renderHeader","previousHeader","getElementsByClassName","chat","parentElement","nextHeader","replaceChild","renderMain","previousMain","nextMain","renderNewMessage","_clearInput","input","value","send","event","querySelector","renderFooter","previousFooter","nextFooter","handleSend","bind","button","addEventListener","render","$aeb01e3ae829b153$export$1586efe9e3013a67","setAttribute","$b4de022fb8244c8b$export$5fe8222595b01ed2","assistants","onClick","_assistants","_onClick","_getActiveAssistant","getActiveAssistantId","getAttribute","_onToggle","selectedAssistant","currentAssistant","remove","toggle","click","currentTarget","handleClick","$a33f52700f6fa316$var$api","path","response","fetch","data","json","ok","$a33f52700f6fa316$export$40ce17753a1d1785","$a33f52700f6fa316$export$426c95e07c389742","$a33f52700f6fa316$export$62651879628e0c4c","userText","method","JSON","stringify","$000500fde1ff7210$export$7ca9b0e795b607f1","initialAssistants","_createInitialAssistant","_createInitialModel","stream","temperature","maxTokens","instruction","getAssistants","getAssistantById","find","updateAssistant","newAssistant","oldAssistant","assign","getDisplayedData","icon","getMessages","addMessage","$1e3f496bba0e4234$export$bd63dc5a00fdc201","_model","_menuView","_onAssistantChange","_updateChatView","_chatView","_onMessageSend","cachedAssistant","serverAssistant","_onMessageAdd","assistantText","init","$cba3eb2abed8e80a$var$start","app","_defaults"],"version":3,"file":"index.19cd5666.js.map"}